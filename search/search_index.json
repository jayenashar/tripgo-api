{
    "docs": [
        {
            "location": "/", 
            "text": "TripGo API\n\n\nThe TripGo API allows you to plan \ndoor-to-door trips\n using a large variety of \npublic and private transport.\n It integrates \nreal-time\n information and, for selected providers, allows users to \nbook and pay\n for transport.\n\n\n\n\n\nGetting started\n\n\n1. Getting an API key\n\n\nGet an API key\n. You can try it out for free for as long as you like, as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the \nSkedGo website\n.\n\n\nOnce you have an API key, send it along with every request as the \nX-TripGo-Key\n header.\n\n\n2. Make a request\n\n\nOur API can do a lot more than just \ndirections\n, but if that is what you are interested in, then try something like:\n\n\ncurl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)\nto=(-33.863,151.208)\ndepartAfter=1532799914\nmodes[]=wa_wal\nv=11\nlocale=en' -H 'Accept: application/json' --compressed -H \nX-TripGo-Key: $tripgoKey\n -g\n\n\n\n\nor \n\n\ncurl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)\nto=(-33.891,151.209)\nmodes[]=pt_pub\nv=11\nlocale=en' -H 'Accept: application/json' --compressed -H \nX-TripGo-Key: $tripgoKey\n -g\n\n\n\n\nKeep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further \nin the F.A.Q.\n.\n\n\n3. Where to go from here?\n\n\n\n\n\n\nIf you're an app developer, take a look at our open source TripKit \nSDKs for \niOS, macOS\n and \nAndroid\n.\n\n\n\n\n\n\nIf you're a web developer, take a look at \nour \nsample app\n \"FastGo\"\n and its accompanying \nblog post series\n, or check out our \nLeaflet Plugin\n (see \nDemo\n).\n\n\n\n\n\n\nIf you're a backend developer, dive into the \nAPI specs\n, which are available in OpenAPI (formerly Swagger) format. \n\n\n\n\n\n\nIf you know how to debug a web app, look at the network activity for \nour web app\n to get an idea of which API calls to use when.  (Filter for \"satapp\".)\n\n\n\n\n\n\nTo talk to us and other developers using our API, join our \nSlack team\n by \nself-invite\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#tripgo-api", 
            "text": "The TripGo API allows you to plan  door-to-door trips  using a large variety of  public and private transport.  It integrates  real-time  information and, for selected providers, allows users to  book and pay  for transport.", 
            "title": "TripGo API"
        }, 
        {
            "location": "/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/#1-getting-an-api-key", 
            "text": "Get an API key . You can try it out for free for as long as you like, as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the  SkedGo website .  Once you have an API key, send it along with every request as the  X-TripGo-Key  header.", 
            "title": "1. Getting an API key"
        }, 
        {
            "location": "/#2-make-a-request", 
            "text": "Our API can do a lot more than just  directions , but if that is what you are interested in, then try something like:  curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207) to=(-33.863,151.208) departAfter=1532799914 modes[]=wa_wal v=11 locale=en' -H 'Accept: application/json' --compressed -H  X-TripGo-Key: $tripgoKey  -g  or   curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207) to=(-33.891,151.209) modes[]=pt_pub v=11 locale=en' -H 'Accept: application/json' --compressed -H  X-TripGo-Key: $tripgoKey  -g  Keep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further  in the F.A.Q. .", 
            "title": "2. Make a request"
        }, 
        {
            "location": "/#3-where-to-go-from-here", 
            "text": "If you're an app developer, take a look at our open source TripKit  SDKs for  iOS, macOS  and  Android .    If you're a web developer, take a look at  our  sample app  \"FastGo\"  and its accompanying  blog post series , or check out our  Leaflet Plugin  (see  Demo ).    If you're a backend developer, dive into the  API specs , which are available in OpenAPI (formerly Swagger) format.     If you know how to debug a web app, look at the network activity for  our web app  to get an idea of which API calls to use when.  (Filter for \"satapp\".)    To talk to us and other developers using our API, join our  Slack team  by  self-invite .", 
            "title": "3. Where to go from here?"
        }, 
        {
            "location": "/faq/", 
            "text": "General\n\n\nLanguages\n\n\n\n\nWhich languages does the API support?\n\n\n\n\nMost text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish.\n\n\nThe translations are done \nin the open on Crowdin\n and everyone can contribute, including adding new languages.\n\n\nOne note of causion: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them.\n\n\n\n\nRegions\n\n\n\n\nWhat are regions?\n\n\n\n\nOur API splits the world into several pieces, which we call regions. Several endpoints require you to pass along a region code, e.g., because identifiers might be duplicated around the world.\n\n\nYou can get a list of regions by quering \nregions.json\n:\n\n\ncurl 'https://api.tripgo.com/v1/regions.json' -H 'Accept: application/json' --compressed -H \nX-TripGo-Key: $tripgoKey\n -d '{\nv\n:2}'\n\n\n\n\nThen extract the polylines from there and match your coordinates to a region. This endpoint also tells you which modes are supported by routing for a given region. \n\n\n\n\nI noticed URLs in those regions, how can/should I use those?\n\n\n\n\nMost developer should not need to worry about these and can just use the \napi.tripgo.com\n domain. However, performance critical application can use this to reduce lag and directly hit the routing servers.\n\n\nFor advanced users\n: This exposes to you that our API is covered by multiple servers - though not every server covers ever region. You can use the URLs to directly query servers covering a certain region \u2013 which can be beneficial to reduce lag and is recommended for server-to-server communication. However, be aware that you should add failover from one server to another yourself then, as individual servers can go down unannounced for maintenance. You should only cache this information short term as those URLs can change without notice.\n\n\n\n\nRouting\n\n\nMode Identifiers\n\n\n\n\nWhat are all these peculiar looking strings such as \npt_pub\n?\n\n\n\n\nSyntax\n\n\nThe syntax of the mode string is like this:\n\n\ngroup\n_\nmode that makes sense to the user\n[_\nprovider or fine-grained mode\n]\n\n\nList of groups\n\n\n\n\npt_\n is for transit which runs on schedules\n\n\nps_\n is for taxi-like on-demand services\n\n\nme_\n is for vehicles you drive yourself\n\n\ncy_\n is for cycling\n\n\nwa_\n is for walking\n\n\nin_\n is for intercity long distance transport\n\n\n\n\npt_\n\n\n\n\npt_pub\n is \"public transit\" that is accessible to public\n\n\npt_pub_bus\n\n\npt_pub_train\n\n\npt_pub_ferry\n\n\npt_pub_tram\n\n\npt_pub_subway\n\n\npt_pub_monorail\n\n\npt_pub_cablecar\n\n\npt_pub_funicular\n\n\npt_pub_gondola\n\n\npt_ltd_SCHOOLBUS\n is public transit of limited access (school buses)\n\n\n\n\nps_\n\n\n\n\nps_tax\n is for taxis\n\n\nps_tnc\n is for uber and alike (TNC is California's official code for them)\n\n\nps_tnc_lyft\n\n\nps_tnc_sidecar\n\n\nps_tnc_uber\n\n\nps_shu\n is for (airport) shuttles\n\n\n\n\nme_\n\n\n\n\nme_car\n is for your own car\n\n\nme_car-s\n is for car sharing (like ZipCar or GoGet)\n\n\nme_car-r\n is for car rental (like Budget)\n\n\nme_car-p\n is for car pooling (like BlaBlaCar)\n\n\nme_mot\n is for your own motorbike\n\n\n\n\n\n\nSingle-modal vs. multi-modal routing\n\n\n\n\nHow do I get these sweet results which combine taxis or other private transport modes with public transport?\n\n\n\n\nYou need to specify multiple modes in the \nrouting.json\n requests, e.g., by using \nmodes=pt_pub\nmodes=ps_tax\n. You can specify a long list of modes as the API will then return suitable combinations for any of those.\n\n\n\n\nWhat if I want to get both public-transport-only results and mixed results?\n\n\n\n\nIn this case you need to currently send off multiple requests, e.g., if you want public transport, taxi, and combinations of the two, you need to send three requests: one with \nmodes=pt_pub\n, one with \nmodes=ps_tax\n, and one with \nmodes=pt_pub\nmodes=ps_tax\n.\n\n\nThe request with multiple modes will only return inter-modal results, no results for individual modes.\n A few things to note about this:\n\n\n\n\nThis is done as inter-modal results can be slower to calculate due to the many combinations to crunch and them being likely to depend on external API calls, slowing things down further.\n\n\nBy having the inter-modal request not returning single-modal results, you don't need to do any duplicate detection between the results of the different calls as they are mutually exclusive.\n\n\nYou'll only get such inter-modal combinations where that combination is better in some way than using any individual mode by itself. It is therefore quite common that inter-modal requests result in an empty response.\n\n\n\n\n\n\nTrips, groups, frequencies and templates\n\n\n\n\nWhat is the logic behind trip groups and what does the frequency property mean?\n\n\n\n\nEach group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times.\n\n\nFrequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group.\n\n\nIn our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest \nweightedScore\n.\n\n\n\n\nWhy are segments split into references and templates?\n\n\n\n\nThis is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.\n\n\n\n\nPlaceholders in segment templates\n\n\n\n\nWhat are all the possible values for placeholders and how should they get interpreted?\n\n\n\n\nIn order to use segment templates for multiple similar segments, the \nnotes\n and \naction\n fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data.\n\n\n\n\nNUMBER\n: Placeholder for the number of short name of the transit service, e.g., \nsegment.serviceNumber\n.\n\n\nLINE_NAME\n: Placeholder for the long name of the transit service, e.g., \nsegment.serviceName\n.\n\n\nDIRECTION\n: Placeholder for the direction of the transit service, e.g., \nsegment.serviceDirection\n.\n\n\nLOCATIONS\n: Placeholder for the start and end location of the segment, e.g., \nsegment.start -\n segment.end\n.\n\n\nPLATFORM\n: Placeholder for the embarkation platform of the transit service, e.g., \nsegment.platform\n.\n\n\nSTOPS\n: Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g., \nsegment.stops\n.\n\n\nTIME\n*: Placeholder for the departure time of the segment, e.g., \nsegment.startTime\n formatted as a time. Note that this can directly follow a \nNUMBER\n template, so you might have to add spacing. \n\n\nDURATION\n*: Placeholder for the total duration of the segment, e.g., \nsegment.endTime - segment.startTime\n formatted as a duration string.\n\n\nTRAFFIC\n: (Badly named) placeholder for the total duration \nwithout\n traffic of the segment, e.g., \nsegment.durationWithoutTraffic\n formatted as a duration string.\n\n\n\n\n*\n: Should be updated with real-time data.\n\n\nAdvanced Routing Features\n\n\n\n\nHow does \nwheelchair\n flag in true affect the resulting trips?\n\n\n\n\nThere are three possible scenarios for public services, public stops, and paths: we know they are wheelchair accessible, we know they are not wheelchair accessible, or we don't have information about them. When the \nwheelchair\n flag is on, our routing engine will try to avoid services, stops and paths that are known by us to be inaccessible. In addition, we'll change 'walking' instructions to 'rolling' instructions, and indicate which sections are accessible, inaccessible or unknown.\n\n\n\n\nWhat's the \naction\n field in the alerts for?\n\n\n\n\nSometimes we get real-time data that may change the accessibility status for public stops, \nfor example when a lift is temporarily out of service in a train station. In these cases, \nwe provide a mechanism that allows to identify the problem and send a re-route request \nspecifically asking to avoid the stop(s) that have become inaccessible.\n\n\nIf the embark/disembark stop of a public segment has issues, then we'll associate that \nsegment with an alert describing the issue and containing a special \naction\n field of \ntype \nrerouteExcludingStops\n which provides a list of the affected stop codes. Then if \nyou want to get a new set of results avoiding those stops, you can add the \navoidStops\n \nparameter to your original routing request, using the stop codes provided in the alert \naction field, and re-send it.\n\n\nNote\n that this new request will only avoid the stops you specifically indicated with the \n\navoidStops\n parameter, so your new set of results may again include an alert for a different\nstop that also has issues. So you may want to send a third request asking to avoid this\none too, but it's important that you include all of them in the \navoidStops\n list, or \notherwise you'll get again the stops that were first excluded.\n\n\n\n\nLocations\n\n\nLocations, cell IDs and hash codes\n\n\n\n\nWhat are the cell IDs in the \nlocations.json\n endpoint?\n\n\n\n\nThe way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as \n$(lat*cellsPerDegree)#$(lng*cellsPerDegree)\n.\n\n\n\n\nGot it. And \ncellIDHashCodes\n?\n\n\n\n\nYou typically call \nlocations.json\n with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use \ncellIDHashCodes\n as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.\n\n\n\n\nExample\n\n\nLet's say, you want the minor stops around CBD of Sydney, Australia. You'll first request:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDs\": [\n    \"-2540#11339\",\n    \"-2540#11340\",\n    \"-2540#11341\",\n    \"-2541#11339\",\n    \"-2541#11340\",\n    \"-2541#11341\",\n    \"-2542#11339\",\n    \"-2542#11340\",\n    \"-2542#11341\"\n  ]\n}\n\n\n\nYou'll then get results:\n\n\n{\n  \"groups\": [\n    {\n      \"hashCode\": 690784261,\n      \"key\": \"-2540#11339\",\n      \"stops\": [...]\n    },\n    {\n      \"hashCode\": -1940969928,\n      \"key\": \"-2540#11340\",\n      \"stops\": [...]\n    }\n  ]\n}\n\n\n\nYou can then cache these and later on request again for changes by supplying \ncellIDHashCodes\n:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDHashCodes\": {\n    \"-2540#11339\": 690784261,\n    \"-2540#11340\": -1940969928\n  }\n}\n\n\n\nWhich will then only return any groups that have changed. If nothing changed, you'll just get back:\n\n\n{\n  \"groups\": []\n}\n\n\n\n\n\nNote\n: You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"cellIDHashCodes\": {\n    \"AU_NSW_Sydney\": 1096794422\n  }\n}", 
            "title": "F.A.Q."
        }, 
        {
            "location": "/faq/#general", 
            "text": "", 
            "title": "General"
        }, 
        {
            "location": "/faq/#languages", 
            "text": "Which languages does the API support?   Most text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish.  The translations are done  in the open on Crowdin  and everyone can contribute, including adding new languages.  One note of causion: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them.", 
            "title": "Languages"
        }, 
        {
            "location": "/faq/#regions", 
            "text": "What are regions?   Our API splits the world into several pieces, which we call regions. Several endpoints require you to pass along a region code, e.g., because identifiers might be duplicated around the world.  You can get a list of regions by quering  regions.json :  curl 'https://api.tripgo.com/v1/regions.json' -H 'Accept: application/json' --compressed -H  X-TripGo-Key: $tripgoKey  -d '{ v :2}'  Then extract the polylines from there and match your coordinates to a region. This endpoint also tells you which modes are supported by routing for a given region.    I noticed URLs in those regions, how can/should I use those?   Most developer should not need to worry about these and can just use the  api.tripgo.com  domain. However, performance critical application can use this to reduce lag and directly hit the routing servers.  For advanced users : This exposes to you that our API is covered by multiple servers - though not every server covers ever region. You can use the URLs to directly query servers covering a certain region \u2013 which can be beneficial to reduce lag and is recommended for server-to-server communication. However, be aware that you should add failover from one server to another yourself then, as individual servers can go down unannounced for maintenance. You should only cache this information short term as those URLs can change without notice.", 
            "title": "Regions"
        }, 
        {
            "location": "/faq/#routing", 
            "text": "", 
            "title": "Routing"
        }, 
        {
            "location": "/faq/#mode-identifiers", 
            "text": "What are all these peculiar looking strings such as  pt_pub ?", 
            "title": "Mode Identifiers"
        }, 
        {
            "location": "/faq/#syntax", 
            "text": "The syntax of the mode string is like this:  group _ mode that makes sense to the user [_ provider or fine-grained mode ]", 
            "title": "Syntax"
        }, 
        {
            "location": "/faq/#list-of-groups", 
            "text": "pt_  is for transit which runs on schedules  ps_  is for taxi-like on-demand services  me_  is for vehicles you drive yourself  cy_  is for cycling  wa_  is for walking  in_  is for intercity long distance transport", 
            "title": "List of groups"
        }, 
        {
            "location": "/faq/#pt_", 
            "text": "pt_pub  is \"public transit\" that is accessible to public  pt_pub_bus  pt_pub_train  pt_pub_ferry  pt_pub_tram  pt_pub_subway  pt_pub_monorail  pt_pub_cablecar  pt_pub_funicular  pt_pub_gondola  pt_ltd_SCHOOLBUS  is public transit of limited access (school buses)", 
            "title": "pt_"
        }, 
        {
            "location": "/faq/#ps_", 
            "text": "ps_tax  is for taxis  ps_tnc  is for uber and alike (TNC is California's official code for them)  ps_tnc_lyft  ps_tnc_sidecar  ps_tnc_uber  ps_shu  is for (airport) shuttles", 
            "title": "ps_"
        }, 
        {
            "location": "/faq/#me_", 
            "text": "me_car  is for your own car  me_car-s  is for car sharing (like ZipCar or GoGet)  me_car-r  is for car rental (like Budget)  me_car-p  is for car pooling (like BlaBlaCar)  me_mot  is for your own motorbike", 
            "title": "me_"
        }, 
        {
            "location": "/faq/#single-modal-vs-multi-modal-routing", 
            "text": "How do I get these sweet results which combine taxis or other private transport modes with public transport?   You need to specify multiple modes in the  routing.json  requests, e.g., by using  modes=pt_pub modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those.   What if I want to get both public-transport-only results and mixed results?   In this case you need to currently send off multiple requests, e.g., if you want public transport, taxi, and combinations of the two, you need to send three requests: one with  modes=pt_pub , one with  modes=ps_tax , and one with  modes=pt_pub modes=ps_tax .  The request with multiple modes will only return inter-modal results, no results for individual modes.  A few things to note about this:   This is done as inter-modal results can be slower to calculate due to the many combinations to crunch and them being likely to depend on external API calls, slowing things down further.  By having the inter-modal request not returning single-modal results, you don't need to do any duplicate detection between the results of the different calls as they are mutually exclusive.  You'll only get such inter-modal combinations where that combination is better in some way than using any individual mode by itself. It is therefore quite common that inter-modal requests result in an empty response.", 
            "title": "Single-modal vs. multi-modal routing"
        }, 
        {
            "location": "/faq/#trips-groups-frequencies-and-templates", 
            "text": "What is the logic behind trip groups and what does the frequency property mean?   Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times.  Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group.  In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest  weightedScore .   Why are segments split into references and templates?   This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.", 
            "title": "Trips, groups, frequencies and templates"
        }, 
        {
            "location": "/faq/#placeholders-in-segment-templates", 
            "text": "What are all the possible values for placeholders and how should they get interpreted?   In order to use segment templates for multiple similar segments, the  notes  and  action  fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data.   NUMBER : Placeholder for the number of short name of the transit service, e.g.,  segment.serviceNumber .  LINE_NAME : Placeholder for the long name of the transit service, e.g.,  segment.serviceName .  DIRECTION : Placeholder for the direction of the transit service, e.g.,  segment.serviceDirection .  LOCATIONS : Placeholder for the start and end location of the segment, e.g.,  segment.start -  segment.end .  PLATFORM : Placeholder for the embarkation platform of the transit service, e.g.,  segment.platform .  STOPS : Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g.,  segment.stops .  TIME *: Placeholder for the departure time of the segment, e.g.,  segment.startTime  formatted as a time. Note that this can directly follow a  NUMBER  template, so you might have to add spacing.   DURATION *: Placeholder for the total duration of the segment, e.g.,  segment.endTime - segment.startTime  formatted as a duration string.  TRAFFIC : (Badly named) placeholder for the total duration  without  traffic of the segment, e.g.,  segment.durationWithoutTraffic  formatted as a duration string.   * : Should be updated with real-time data.", 
            "title": "Placeholders in segment templates"
        }, 
        {
            "location": "/faq/#advanced-routing-features", 
            "text": "How does  wheelchair  flag in true affect the resulting trips?   There are three possible scenarios for public services, public stops, and paths: we know they are wheelchair accessible, we know they are not wheelchair accessible, or we don't have information about them. When the  wheelchair  flag is on, our routing engine will try to avoid services, stops and paths that are known by us to be inaccessible. In addition, we'll change 'walking' instructions to 'rolling' instructions, and indicate which sections are accessible, inaccessible or unknown.   What's the  action  field in the alerts for?   Sometimes we get real-time data that may change the accessibility status for public stops, \nfor example when a lift is temporarily out of service in a train station. In these cases, \nwe provide a mechanism that allows to identify the problem and send a re-route request \nspecifically asking to avoid the stop(s) that have become inaccessible.  If the embark/disembark stop of a public segment has issues, then we'll associate that \nsegment with an alert describing the issue and containing a special  action  field of \ntype  rerouteExcludingStops  which provides a list of the affected stop codes. Then if \nyou want to get a new set of results avoiding those stops, you can add the  avoidStops  \nparameter to your original routing request, using the stop codes provided in the alert \naction field, and re-send it.  Note  that this new request will only avoid the stops you specifically indicated with the  avoidStops  parameter, so your new set of results may again include an alert for a different\nstop that also has issues. So you may want to send a third request asking to avoid this\none too, but it's important that you include all of them in the  avoidStops  list, or \notherwise you'll get again the stops that were first excluded.", 
            "title": "Advanced Routing Features"
        }, 
        {
            "location": "/faq/#locations", 
            "text": "", 
            "title": "Locations"
        }, 
        {
            "location": "/faq/#locations-cell-ids-and-hash-codes", 
            "text": "What are the cell IDs in the  locations.json  endpoint?   The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as  $(lat*cellsPerDegree)#$(lng*cellsPerDegree) .   Got it. And  cellIDHashCodes ?   You typically call  locations.json  with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use  cellIDHashCodes  as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.", 
            "title": "Locations, cell IDs and hash codes"
        }, 
        {
            "location": "/faq/#example", 
            "text": "Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request:  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDs\": [\n    \"-2540#11339\",\n    \"-2540#11340\",\n    \"-2540#11341\",\n    \"-2541#11339\",\n    \"-2541#11340\",\n    \"-2541#11341\",\n    \"-2542#11339\",\n    \"-2542#11340\",\n    \"-2542#11341\"\n  ]\n}  You'll then get results:  {\n  \"groups\": [\n    {\n      \"hashCode\": 690784261,\n      \"key\": \"-2540#11339\",\n      \"stops\": [...]\n    },\n    {\n      \"hashCode\": -1940969928,\n      \"key\": \"-2540#11340\",\n      \"stops\": [...]\n    }\n  ]\n}  You can then cache these and later on request again for changes by supplying  cellIDHashCodes :  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDHashCodes\": {\n    \"-2540#11339\": 690784261,\n    \"-2540#11340\": -1940969928\n  }\n}  Which will then only return any groups that have changed. If nothing changed, you'll just get back:  {\n  \"groups\": []\n}   Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself:  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"cellIDHashCodes\": {\n    \"AU_NSW_Sydney\": 1096794422\n  }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/extensions/", 
            "text": "Extensions\n\n\nRight after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system.\n\n\nThe TripGo API can be extended in the following ways:\n\n\n\n\nUnlock transport modes, regions and real-time data from services that require you to first accept their terms or acquire API credentials.\n\n\nAdd new transport modes through our TSP Connectors (coming soon).\n\n\nAdd new regions through our Region Connectors (coming soon).\n\n\n\n\n\n\nUnlocking transport modes\n\n\nTo get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team \nby mail\n or on Slack.\n\n\nBlaBlaCar \ud83c\udf0d\n\n\nIntegrations\n: Routing, Real-time\n\n\n\n\nRead the \nterms of use of BlaBlaCar's API\n and make sure you comply with them in your app.\n\n\nSign up to \nBlaBlaCar's API\n.\n\n\nEnter your \nBlaBlaCar auth key\n in your \napplication credentials\n.\n\n\nBlaBlaCar results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nCar2go \ud83c\udf0f\n\n\nIntegrations\n: Locations, Routing, Real-time, Bookings\n\n\n\n\nRead the \nterms of use of the car2go API\n and make sure you comply with them in your app.\n\n\nMail openapi@car2go.com\n as described in there.\n\n\nEnter your \nCar2go consumerKey\n in your \napplication credentials\n.\n\n\nCar2go results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\n\n\n\nFlinkster \ud83c\uddea\ud83c\uddfa\n\n\nIntegrations\n: Locations, Routing, Real-time\n\n\n\n\nSign up to \nDeutsche Bahn's Flinkster API\n\n\nLogin to Deutsche Bahn's developer website, select \"My Subscriptions\" and generate an \"Access Token\"\n\n\nEnter this as your \nFlinkster access token\n in your \napplication credentials\n.\n\n\nFlinkster results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nFlit \ud83c\udf0e\n\n\nIntegrations\n: Routing, Real-time\n\n\n\n\nGet in touch with Flit and get access to \ntheir API\n.\n\n\nEnter your \nFlit api key\n in your \napplication credentials\n.\n\n\nFlit results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nMyDriver \ud83c\udf0e\n\n\nIntegrations\n: Routing, Real-time\n\n\n\n\nGet in touch with \nMyDriver\n's sales team and get access to their API.\n\n\nEnter your \nMyDriver username\n and \nMyDriver password\n in your \napplication credentials\n.\n\n\nMyDriver results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nLyft \ud83c\uddfa\ud83c\uddf8\n\n\nIntegrations\n: Routing, Real-time, Bookings\n\n\n\n\nRead the \nterms of use of Lyft's API\n and make sure you comply with them in your app.\n\n\nSign up to \nLyft's API\n.\n\n\nEnter your \nLyft Client ID\n and \nLyft Client Secret\n in your \napplication credentials\n.\n\n\nLyft results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nUber \ud83c\udf0e\n\n\nIntegrations\n: Routing, Real-time, Bookings\n\n\n\n\nRead the \nterms of use of Uber's API\n and make sure you comply with them in your app.\n\n\nSign up to \nUber's ride request API\n.\n\n\nEnter your \nUber client ID\n, \nUber client secret\n and \nUber server token\n in your \napplication credentials\n. \n\n\nUber results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nZipcar \ud83c\uddfa\ud83c\uddf8\n\n\nIntegrations\n: Locations, Routing, Real-time\n\n\n\n\nGet in touch with \nZipcar\n and get access to their API.\n\n\nEnter your \nZipcar API key\n in your \napplication credentials\n. \n\n\nZipcar results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nGoGet \ud83c\udde6\ud83c\uddfa\n\n\nIntegrations\n: Locations, Routing, Real-time\n\n\n\n\nGet in touch with \nGoGet\n's sales team and get access to their API.\n\n\nEnter your \nGoGet ConsumerKey\n and \nGoGet ConsumerSecret\n in your \napplication credentials\n.\n\n\nGoGet results will start coming through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\n\n\nUnlocking real-time data\n\n\nTo get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team \nby mail\n or on \nSlack\n (by \nself-invite\n).\n\n\nLive-Traffic from Google \ud83c\udf0e\n\n\n\n\nRead the \nterms of use of Google Maps\n and make sure you comply with them in your app - in particular, that you are using a Google Map.\n\n\nSign up to the \nGoogle Maps Directions API\n\n\nEnter your \nGoogle Maps Directions API key\n in your \napplication credentials\n. \n\n\nCar results leaving now will then come augmented with Google's drive time predictions through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nLive-Traffic from TomTom \ud83c\udf0e\n\n\n\n\nSign up to the \nTomTom Maps API\n, making sure you read the terms and comply with them - in particular, that you're not affiliated with a prohibited party and that you're using a TomTom or TomTom licenses map UI (e.g., Apple Maps).\n\n\nEnter your \nTomTom consumer API key\n and \nTomTom consumer secret\n in your \napplication credentials\n. \n\n\nCar results leaving now will then come augmented with TomTom's drive time predictions through the TripGo API for your API key (after at most 5 minutes).\n\n\n\n\nChicago's CTA \ud83c\uddfa\ud83c\uddf8\n\n\n\n\nRead the \nterms of use of CTA's API\n and make sure you comply with them in your app\n\n\nSign up to \nCTA's API\n\n\nEnter your \nCTA key for Chicago\n in your \napplication credentials\n. \n\n\nReal-time data for CTA for your TripGo API key will be enabled (after at most 5 minutes).\n\n\n\n\n\n\n\n\n\nUnlocking regions\n\n\nTo get results for regions with providers that aren't using Open Data, or which we haven't yet been connected to our system, please get in touch with our team \nby mail\n or on \nSlack\n (by \nself-invite\n).", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/#extensions", 
            "text": "Right after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system.  The TripGo API can be extended in the following ways:   Unlock transport modes, regions and real-time data from services that require you to first accept their terms or acquire API credentials.  Add new transport modes through our TSP Connectors (coming soon).  Add new regions through our Region Connectors (coming soon).", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/#unlocking-transport-modes", 
            "text": "To get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team  by mail  or on Slack.", 
            "title": "Unlocking transport modes"
        }, 
        {
            "location": "/extensions/#blablacar", 
            "text": "Integrations : Routing, Real-time   Read the  terms of use of BlaBlaCar's API  and make sure you comply with them in your app.  Sign up to  BlaBlaCar's API .  Enter your  BlaBlaCar auth key  in your  application credentials .  BlaBlaCar results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "BlaBlaCar \ud83c\udf0d"
        }, 
        {
            "location": "/extensions/#car2go", 
            "text": "Integrations : Locations, Routing, Real-time, Bookings   Read the  terms of use of the car2go API  and make sure you comply with them in your app.  Mail openapi@car2go.com  as described in there.  Enter your  Car2go consumerKey  in your  application credentials .  Car2go results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "Car2go \ud83c\udf0f"
        }, 
        {
            "location": "/extensions/#flinkster", 
            "text": "Integrations : Locations, Routing, Real-time   Sign up to  Deutsche Bahn's Flinkster API  Login to Deutsche Bahn's developer website, select \"My Subscriptions\" and generate an \"Access Token\"  Enter this as your  Flinkster access token  in your  application credentials .  Flinkster results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "Flinkster \ud83c\uddea\ud83c\uddfa"
        }, 
        {
            "location": "/extensions/#flit", 
            "text": "Integrations : Routing, Real-time   Get in touch with Flit and get access to  their API .  Enter your  Flit api key  in your  application credentials .  Flit results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "Flit \ud83c\udf0e"
        }, 
        {
            "location": "/extensions/#mydriver", 
            "text": "Integrations : Routing, Real-time   Get in touch with  MyDriver 's sales team and get access to their API.  Enter your  MyDriver username  and  MyDriver password  in your  application credentials .  MyDriver results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "MyDriver \ud83c\udf0e"
        }, 
        {
            "location": "/extensions/#lyft", 
            "text": "Integrations : Routing, Real-time, Bookings   Read the  terms of use of Lyft's API  and make sure you comply with them in your app.  Sign up to  Lyft's API .  Enter your  Lyft Client ID  and  Lyft Client Secret  in your  application credentials .  Lyft results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "Lyft \ud83c\uddfa\ud83c\uddf8"
        }, 
        {
            "location": "/extensions/#uber", 
            "text": "Integrations : Routing, Real-time, Bookings   Read the  terms of use of Uber's API  and make sure you comply with them in your app.  Sign up to  Uber's ride request API .  Enter your  Uber client ID ,  Uber client secret  and  Uber server token  in your  application credentials .   Uber results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "Uber \ud83c\udf0e"
        }, 
        {
            "location": "/extensions/#zipcar", 
            "text": "Integrations : Locations, Routing, Real-time   Get in touch with  Zipcar  and get access to their API.  Enter your  Zipcar API key  in your  application credentials .   Zipcar results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "Zipcar \ud83c\uddfa\ud83c\uddf8"
        }, 
        {
            "location": "/extensions/#goget", 
            "text": "Integrations : Locations, Routing, Real-time   Get in touch with  GoGet 's sales team and get access to their API.  Enter your  GoGet ConsumerKey  and  GoGet ConsumerSecret  in your  application credentials .  GoGet results will start coming through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "GoGet \ud83c\udde6\ud83c\uddfa"
        }, 
        {
            "location": "/extensions/#unlocking-real-time-data", 
            "text": "To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team  by mail  or on  Slack  (by  self-invite ).", 
            "title": "Unlocking real-time data"
        }, 
        {
            "location": "/extensions/#live-traffic-from-google", 
            "text": "Read the  terms of use of Google Maps  and make sure you comply with them in your app - in particular, that you are using a Google Map.  Sign up to the  Google Maps Directions API  Enter your  Google Maps Directions API key  in your  application credentials .   Car results leaving now will then come augmented with Google's drive time predictions through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "Live-Traffic from Google \ud83c\udf0e"
        }, 
        {
            "location": "/extensions/#live-traffic-from-tomtom", 
            "text": "Sign up to the  TomTom Maps API , making sure you read the terms and comply with them - in particular, that you're not affiliated with a prohibited party and that you're using a TomTom or TomTom licenses map UI (e.g., Apple Maps).  Enter your  TomTom consumer API key  and  TomTom consumer secret  in your  application credentials .   Car results leaving now will then come augmented with TomTom's drive time predictions through the TripGo API for your API key (after at most 5 minutes).", 
            "title": "Live-Traffic from TomTom \ud83c\udf0e"
        }, 
        {
            "location": "/extensions/#chicagos-cta", 
            "text": "Read the  terms of use of CTA's API  and make sure you comply with them in your app  Sign up to  CTA's API  Enter your  CTA key for Chicago  in your  application credentials .   Real-time data for CTA for your TripGo API key will be enabled (after at most 5 minutes).", 
            "title": "Chicago's CTA \ud83c\uddfa\ud83c\uddf8"
        }, 
        {
            "location": "/extensions/#unlocking-regions", 
            "text": "To get results for regions with providers that aren't using Open Data, or which we haven't yet been connected to our system, please get in touch with our team  by mail  or on  Slack  (by  self-invite ).", 
            "title": "Unlocking regions"
        }, 
        {
            "location": "/enterprise/push/", 
            "text": "Push Notifications\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\n\n\nWe support Push Notifications for both Android (using \nFirebase\n) and iOS (using \nAPN\n) devices. In order to enable and use Push Notifications, the following steps are required:\n\n\n\n\nRegister (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details).\n\n\nEach app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using \ndata/user/push\n endpoint.\n\n\nTo send PN to your user, you need to know the user ID on our database and use \ndata/push\n endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted). \n\n\n\n\nAndroid\n\n\nYou need to create your own project in \nFirebase\n and send to us the \nServer Key\n in your \nproject settings \n cloud messaging\n tab.\n\n\nFor instructions on how to implement Push Notifications in Android, go to \nFirebase Cloud Messaging\n.\n\n\nIn short, your app needs to register into FCM to get a token and save it into our database for later usage (see \ndata/user/push\n endpoint). Note that this token may change, any time that happens you need to save it again in the database.\n\n\niOS\n\n\nYou need to configure your app for APN, follow instructions \nfrom Apple\n or \nuse fastlane\n, and then send us both the P12 file, containing the \nApple Push Notification Authentication Key\n, and the password to unlock it.\n\n\nFor instructions on how to implement Push Notifications in iOS, go to \nConfiguring Remote Notification\n.\n\n\nIn short, your app needs to register into APN to get a token and save it into our database for later usage (see \ndata/user/push\n endpoint). Note that this token may change, any time that happens you need to save it again in the database. The token returned by the iOS SDK will be a binary data object, while our backend expends a string. To turn the data into a string, use this snipped:\n\n\nlet tokenString = tokenData.reduce(into: \n) { $0.append(String(format: \n%02X\n, $1)) }\n\n\n\n\nWhen receiving push notifications, additional fields that were provide in the \ndata\n part when sending the notification, will be accessible to your app via the \nuserInfo\n that's attached to the content of the notification. The \nclickAction\n will end up in the notification's content's \ncategoryIdentifier\n.\n\n\nSending PN\n\n\nIf you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use \ndata/push\n endpoint to send notifications to a list of users (by their userID).\n\n\nNotifications that we send support a title, message, sound and badge, with a ttl (time to live) value, as well as custom \ndata\n which will be passed on to your apps. Be mindful of size limits imposed by Firebase or APN.", 
            "title": "Push Notifications"
        }, 
        {
            "location": "/enterprise/push/#push-notifications", 
            "text": "Note: Enterprise customers-only  Note: Beta-only   We support Push Notifications for both Android (using  Firebase ) and iOS (using  APN ) devices. In order to enable and use Push Notifications, the following steps are required:   Register (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details).  Each app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using  data/user/push  endpoint.  To send PN to your user, you need to know the user ID on our database and use  data/push  endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted).", 
            "title": "Push Notifications"
        }, 
        {
            "location": "/enterprise/push/#android", 
            "text": "You need to create your own project in  Firebase  and send to us the  Server Key  in your  project settings   cloud messaging  tab.  For instructions on how to implement Push Notifications in Android, go to  Firebase Cloud Messaging .  In short, your app needs to register into FCM to get a token and save it into our database for later usage (see  data/user/push  endpoint). Note that this token may change, any time that happens you need to save it again in the database.", 
            "title": "Android"
        }, 
        {
            "location": "/enterprise/push/#ios", 
            "text": "You need to configure your app for APN, follow instructions  from Apple  or  use fastlane , and then send us both the P12 file, containing the  Apple Push Notification Authentication Key , and the password to unlock it.  For instructions on how to implement Push Notifications in iOS, go to  Configuring Remote Notification .  In short, your app needs to register into APN to get a token and save it into our database for later usage (see  data/user/push  endpoint). Note that this token may change, any time that happens you need to save it again in the database. The token returned by the iOS SDK will be a binary data object, while our backend expends a string. To turn the data into a string, use this snipped:  let tokenString = tokenData.reduce(into:  ) { $0.append(String(format:  %02X , $1)) }  When receiving push notifications, additional fields that were provide in the  data  part when sending the notification, will be accessible to your app via the  userInfo  that's attached to the content of the notification. The  clickAction  will end up in the notification's content's  categoryIdentifier .", 
            "title": "iOS"
        }, 
        {
            "location": "/enterprise/push/#sending-pn", 
            "text": "If you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use  data/push  endpoint to send notifications to a list of users (by their userID).  Notifications that we send support a title, message, sound and badge, with a ttl (time to live) value, as well as custom  data  which will be passed on to your apps. Be mindful of size limits imposed by Firebase or APN.", 
            "title": "Sending PN"
        }, 
        {
            "location": "/enterprise/bookings-api/", 
            "text": "Overview\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\nThe TripGo API allows making bookings for a handful of transport service providers (TSPs).\n\n\nThis enables your users to:\n\n\n\n\nLink their TSP accounts and keep credentials either stored on the client or server-side.\n\n\nGet a list of available TSP products for a trip.\n\n\nBook a specific TSP product for a single segment.\n\n\nUpdate the trip with the details of the booked TSP product.\n\n\nUpdate the trip with real-time data specific to that booking.\n\n\n\n\nComing soon:\n\n\n\n\nBook a complete trip consisting of multiple products from multiple TSPs.\n\n\n\n\nIn order to enable bookings for your TripGo API key, please \nget in touch with our team\n. For most TSPs, you will need to provide us with additional information of your API credentials.\n\n\n\n\nAPI Endpoints\n\n\nLinking and unlinking accounts\n\n\nBefore you can do any bookings, you will need to provide the relevant authentication details to the server.\n\n\nIf the user has an account (as per the \nuserToken\n header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet.\n\n\n\n\nauth/{region}?mode={mode}\n: Endpoint to get the available providers for a specific region, with the information to signin/logout if a \nuserToken\n is provided in the headers. If \nmode\n is provided, only information for that mode is returned.\n\n\nauth/{provider}/signin\n: Endpoint to link an account for the specified provider.\n\n\nauth/{provider}/logout\n: Endpoint to unlink an account for the specified provider.\n\n\n\n\nAuth Flow\n\n\nThis flow will depend on the TSP and can be started in two separate ways:\n\n\n\n\nWhen \nlinking accounts\n to a user.\n\n\nWhen doing a \nbooking\n for that particular TSP and the user has no account already linked.\n\n\n\n\nThis flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow.\n\n\nFor a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including \nclientId\n, \nclientSecret\n, \nscope\n, \nauthUrl\n, \ntokenUrl\n; and also the required field to be POSTed, including \naccessToken\n, \nrefreshToken\n and \nexpiration\n.\n\n\nFor a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for \nForm-based Booking Flow\n.\n\n\nThe end of this flow will depending on how it was started.\nIf was started to link an account, the flow will end with an empty 204 response, when successfuly linked.\nIf it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of \nForm-based Booking Flow\n.\n\n\n\n\nGetting available TSP for a trip\n\n\nIf there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment.\n\n\nThe booking object in the segment may include:\n\n\n\n\na \nquickBookingUrl\n, indicating that the quick booking flow is available.\n\n\na \nbookingUrl\n, indicating that the form-based booking flow is available.\n\n\n\n\n\n\nBooking a segment\n\n\nTo book a segment, either use the \nForm-based Booking Flow\n with the \nbookingURL\n either directly from the segment reference, or the \nQuick Booking Flow\n from the data returned after hitting \nquickBookingUrl\n.\n\n\nForm-based Booking Flow\n\n\nIf form-based booking flow is available for a segment, the \nbookingUrl\n will return a \nBooking Form\n object with instructions to start the booking flow.\n\nA form-based booking flow will possible include the following steps:\n\n\n1) return the available TSP products to allow the user choose one of them, \n2) check whether we have user credentials to do the booking, if it does, skip 3,\n3) start \nAuth flow\n,\n4) attempt to do the booking and return the Status Form.\n\n\nQuick Booking Flow\n\n\nGetting available TSP products for a trip\n\n\nIf quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. \n\n\nAs part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come:\n\n\n\n\ntripUpdateURL\n: A URL for fetching the trip, updated for this TSP product.\n\n\nbookingURL\n: A URL for initiating the booking flow for this TSP product (step 2 of \nform-based booking flow\n)\n\n\ntitle\n\n\nsubtitle\n\n\nbookingTitle\n\n\npriceString\n\n\nprice\n\n\nUSDPrice\n\n\nsurgeString\n\n\nsurgeImageURL\n\n\nETA\n\n\nimageURL\n\n\n\n\n\n\nUpdating trip with booking details\n\n\nAt the end of the booking flow, you will get a \nrefreshURLForSourceObject\n. Hit this URL with a GET request, to get the updated trip.\n\n\nNote that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking.\n\n\nTrips with a confirmed booking will also have extra information about the confirmed booking in a field called \nconfirmation\n in the \nbooking\n field of the segment.\n\n\nThis \nconfirmation\n object may include detailed information about the \nprovider\n, \nvehicle\n and \nstatus\n for the booking, with the following possible fields:\n\n\n\n\na \ntitle\n\n\na \nsubtitle\n\n\na \nvalueUrl\n\n\na \nvalue\n\n\n\n\nAnd also a list of possible actions depending on the status of the booking, with the following fields:\n\n\n\n\na \ntitle\n\n\na boolean \nisDestructive\n, indicating whether this action will cancel the booking.\n\n\na \ninternalUrl\n indicating the action of the url is a call to the same server and will return a \nbookingForm\n.\n\n\na \nexternalUrl\n indicating that the action must be handled by the app accordingly.\n\n\n\n\nExamples of actions with \ninternalUrl\n fields are \ncancel booking\n, which will have the \nisDestructive\n field in true, and \nrate booking\n.\n\n\nExamples of actions with \nexternalUrl\n fields are \nqrcode\n values, for showing a ticket to the user, and phone numbers, starting with \ntel:\n.\n\n\n\n\nRating and Tipping\n\n\nWhenever available, the confirmation information will include the \nrate booking\n action, which will include an \ninternalUrl\n which will return a \nbookingForm\n with the following fields:\n\n\n\n\nrate\n, an int value with min and max accepted values.\n\n\nfeedback\n, a string to send an appropriate msg.\n\n\ntip\n, an int value indicating the amount to be paid as tip, in local currency.\n\n\n\n\nThe booking form will include the action url to POST the data.\n\n\n\n\nBooking Form Specs\n\n\nBoth the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps.\n\n\nThere exists three different forms:\n\n\n\n\nBooking Form\n\n\nAuth Form\n\n\nStatus Form\n\n\n\n\nAll three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data.\n\n\nA Booking Form may include:\n\n\n\n\na title\n\n\na subtitle\n\n\na value\n\n\na \nBookingAction\n, which may include:\n\n\na \nURL\n, to go to the next step in the flow\n\n\na \ntitle\n\n\na \nhudText\n, with a human readable string describing the action (meant to be shown while waiting the response from the backend)\n\n\na boolean \nfinalStep\n, meaning that the next step is the one that will actually do the booking.\n\n\na boolean \ndone\n, indicating that there are no more steps in the flow.\n\n\n\n\n\n\na list of \nFormGroups\n.\n\n\n\n\nA \nFormGroup\n is a lisf of \nFormFields\n with a title and an optional footer.\nA \nFormField\n is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include:\n\n\n\n\na (unique) \nid\n, to identify the field\n\n\na \ntitle\n\n\na \nsubtitle\n\n\na \nsidetitle\n\n\na \nvalue\n, that will depend on the FormField type\n\n\na boolean \nrequired\n, indicating that this is a required field to be POSTed,\n\n\na boolean \nreadOnly\n, indicating that this is information to be shown to the user but can not be edited.\n\n\na boolean \nhidden\n, indicating that this field should NOT be shown to the user.\n\n\n\n\nThere are several types of FormFields:\n\n\n\n\nstring\n, which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER}\n\n\ntext\n, for long non-editable strings\n\n\nswitch\n, for boolean values\n\n\noption\n, for a list of values, will include the list and the default value\n\n\naddress\n, for locations, value with the following format {lat, lng, address, name}\n\n\ndatetime\n, including the time value in long and an extra field with the timezone id \n\n\nstepper\n, for int values, with extra max and min values\n\n\ntime\n, for seconds since midnight\n\n\npassword\n\n\nlink\n, for urls, with an extra field called \nmethod\n with the following possible values:\n\n\nrefresh\n meaning that this url will return the same step form,\n\n\npost\n meaning that the backend expects a POST on that url,\n\n\n\n\nexternal\n meaning that this will go to an external site, so, no BookingForm will be returned.\n\n\n\n\n\n\nbookingForm\n, this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request.\nFor example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.\n\n\n\n\n\n\n\n\nBookings in the TripKit SDKs\n\n\nThe TripKit SDKs implement support for bookings:\n\n\n\n\nBookings in TripKit Android (coming soon)\n\n\nBookings in TripKit iOS", 
            "title": "Bookings (API)"
        }, 
        {
            "location": "/enterprise/bookings-api/#overview", 
            "text": "Note: Enterprise customers-only  Note: Beta-only  The TripGo API allows making bookings for a handful of transport service providers (TSPs).  This enables your users to:   Link their TSP accounts and keep credentials either stored on the client or server-side.  Get a list of available TSP products for a trip.  Book a specific TSP product for a single segment.  Update the trip with the details of the booked TSP product.  Update the trip with real-time data specific to that booking.   Coming soon:   Book a complete trip consisting of multiple products from multiple TSPs.   In order to enable bookings for your TripGo API key, please  get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials.", 
            "title": "Overview"
        }, 
        {
            "location": "/enterprise/bookings-api/#api-endpoints", 
            "text": "", 
            "title": "API Endpoints"
        }, 
        {
            "location": "/enterprise/bookings-api/#linking-and-unlinking-accounts", 
            "text": "Before you can do any bookings, you will need to provide the relevant authentication details to the server.  If the user has an account (as per the  userToken  header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet.   auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a  userToken  is provided in the headers. If  mode  is provided, only information for that mode is returned.  auth/{provider}/signin : Endpoint to link an account for the specified provider.  auth/{provider}/logout : Endpoint to unlink an account for the specified provider.", 
            "title": "Linking and unlinking accounts"
        }, 
        {
            "location": "/enterprise/bookings-api/#auth-flow", 
            "text": "This flow will depend on the TSP and can be started in two separate ways:   When  linking accounts  to a user.  When doing a  booking  for that particular TSP and the user has no account already linked.   This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow.  For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including  clientId ,  clientSecret ,  scope ,  authUrl ,  tokenUrl ; and also the required field to be POSTed, including  accessToken ,  refreshToken  and  expiration .  For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for  Form-based Booking Flow .  The end of this flow will depending on how it was started.\nIf was started to link an account, the flow will end with an empty 204 response, when successfuly linked.\nIf it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of  Form-based Booking Flow .", 
            "title": "Auth Flow"
        }, 
        {
            "location": "/enterprise/bookings-api/#getting-available-tsp-for-a-trip", 
            "text": "If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment.  The booking object in the segment may include:   a  quickBookingUrl , indicating that the quick booking flow is available.  a  bookingUrl , indicating that the form-based booking flow is available.", 
            "title": "Getting available TSP for a trip"
        }, 
        {
            "location": "/enterprise/bookings-api/#booking-a-segment", 
            "text": "To book a segment, either use the  Form-based Booking Flow  with the  bookingURL  either directly from the segment reference, or the  Quick Booking Flow  from the data returned after hitting  quickBookingUrl .", 
            "title": "Booking a segment"
        }, 
        {
            "location": "/enterprise/bookings-api/#form-based-booking-flow", 
            "text": "If form-based booking flow is available for a segment, the  bookingUrl  will return a  Booking Form  object with instructions to start the booking flow. \nA form-based booking flow will possible include the following steps:  1) return the available TSP products to allow the user choose one of them, \n2) check whether we have user credentials to do the booking, if it does, skip 3,\n3) start  Auth flow ,\n4) attempt to do the booking and return the Status Form.", 
            "title": "Form-based Booking Flow"
        }, 
        {
            "location": "/enterprise/bookings-api/#quick-booking-flow", 
            "text": "Getting available TSP products for a trip  If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details.   As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come:   tripUpdateURL : A URL for fetching the trip, updated for this TSP product.  bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of  form-based booking flow )  title  subtitle  bookingTitle  priceString  price  USDPrice  surgeString  surgeImageURL  ETA  imageURL", 
            "title": "Quick Booking Flow"
        }, 
        {
            "location": "/enterprise/bookings-api/#updating-trip-with-booking-details", 
            "text": "At the end of the booking flow, you will get a  refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip.  Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking.  Trips with a confirmed booking will also have extra information about the confirmed booking in a field called  confirmation  in the  booking  field of the segment.  This  confirmation  object may include detailed information about the  provider ,  vehicle  and  status  for the booking, with the following possible fields:   a  title  a  subtitle  a  valueUrl  a  value   And also a list of possible actions depending on the status of the booking, with the following fields:   a  title  a boolean  isDestructive , indicating whether this action will cancel the booking.  a  internalUrl  indicating the action of the url is a call to the same server and will return a  bookingForm .  a  externalUrl  indicating that the action must be handled by the app accordingly.   Examples of actions with  internalUrl  fields are  cancel booking , which will have the  isDestructive  field in true, and  rate booking .  Examples of actions with  externalUrl  fields are  qrcode  values, for showing a ticket to the user, and phone numbers, starting with  tel: .", 
            "title": "Updating trip with booking details"
        }, 
        {
            "location": "/enterprise/bookings-api/#rating-and-tipping", 
            "text": "Whenever available, the confirmation information will include the  rate booking  action, which will include an  internalUrl  which will return a  bookingForm  with the following fields:   rate , an int value with min and max accepted values.  feedback , a string to send an appropriate msg.  tip , an int value indicating the amount to be paid as tip, in local currency.   The booking form will include the action url to POST the data.", 
            "title": "Rating and Tipping"
        }, 
        {
            "location": "/enterprise/bookings-api/#booking-form-specs", 
            "text": "Both the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps.  There exists three different forms:   Booking Form  Auth Form  Status Form   All three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data.  A Booking Form may include:   a title  a subtitle  a value  a  BookingAction , which may include:  a  URL , to go to the next step in the flow  a  title  a  hudText , with a human readable string describing the action (meant to be shown while waiting the response from the backend)  a boolean  finalStep , meaning that the next step is the one that will actually do the booking.  a boolean  done , indicating that there are no more steps in the flow.    a list of  FormGroups .   A  FormGroup  is a lisf of  FormFields  with a title and an optional footer.\nA  FormField  is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include:   a (unique)  id , to identify the field  a  title  a  subtitle  a  sidetitle  a  value , that will depend on the FormField type  a boolean  required , indicating that this is a required field to be POSTed,  a boolean  readOnly , indicating that this is information to be shown to the user but can not be edited.  a boolean  hidden , indicating that this field should NOT be shown to the user.   There are several types of FormFields:   string , which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER}  text , for long non-editable strings  switch , for boolean values  option , for a list of values, will include the list and the default value  address , for locations, value with the following format {lat, lng, address, name}  datetime , including the time value in long and an extra field with the timezone id   stepper , for int values, with extra max and min values  time , for seconds since midnight  password  link , for urls, with an extra field called  method  with the following possible values:  refresh  meaning that this url will return the same step form,  post  meaning that the backend expects a POST on that url,   external  meaning that this will go to an external site, so, no BookingForm will be returned.    bookingForm , this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request.\nFor example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.", 
            "title": "Booking Form Specs"
        }, 
        {
            "location": "/enterprise/bookings-api/#bookings-in-the-tripkit-sdks", 
            "text": "The TripKit SDKs implement support for bookings:   Bookings in TripKit Android (coming soon)  Bookings in TripKit iOS", 
            "title": "Bookings in the TripKit SDKs"
        }, 
        {
            "location": "/enterprise/bookings-ios/", 
            "text": "Bookings in TripKit iOS\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\nTripKit iOS supports all the booking API endpoints, including handling the OAuth process. OAuth credentials are stored securely in the device's keychain and, optionally, linked to the user's account.\n\n\nPreparations\n\n\nTo get started, configured your project as follows:\n\n\n\n\nInclude \nBookingKit\n from \nshared-ios\n, including all its dependencies.\n\n\nInclude \ntripkit-ios\n as a dependency, including its \nBookings\n add-on.\n\n\nAdd the \nOAuthCallbackURL\n to your \nConfig.plist\n configuration file.\n\n\nMake sure your app has the URL scheme from that callback URL registered.\n\n\n\n\nNext, you need to respond to calls to that \nOAuthCallbackURL\n in your application delegate by implementing \napplication(openURL:options)\n (or its deprecated precursors), and handling the calls similar to this:\n\n\nlet OAuthCallbackURL = SGKConfig.sharedIntance().oauthCallbackURL()\nif (URL.absoluteString.hasPrefix(OAuthCallbackURL.absoluteString)) {\n  OAuthSwift.handleOpenURL(URL)\n  return true\n}\n\n\n\n\n\n\nLinking and unlinking accounts\n\n\nYou can then which accounts are available for linking for a given region:\n\n\nlet region = SVKRegionManager.sharedInstance().regionWithName(...)\nregion.linkedAccounts() { auths in\n  for auth in auths {\n    if auth.isConnected {\n      // Update UI and allow unlinking\n    } else {\n      // Update UI and allow linking\n    }\n  }\n}\n\n\n\n\nThis both checks which modes can be associated with an account, and also whether the credentials are already available. Credentials are available when they are either stored locally or associated with the user's account, \nand\n they have not expired.\n\n\nTo kick of linking, which saves the credentials locally and to the user's account (if the user is logged in), there's a helper based on \nRxSwift\n:\n\n\nregion.rx_linkAccount(mode, remoteURL: auth.actionURL)\n  .subscribe { event in\n    switch event {\n    case .Next(let success):\n      // Account has been linked. Update the UI.\n    case .Error(let error):\n      // Account could not get linked. Handle error.\n      print(error)\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n\n\n\n\nNote that this helper requires the \nactionURL\n as this is used to fetch what information is necessary for the OAuth flow for the provider servicing the specified \nmode\n:\n\n\nThese credentials will then be used automatically later on when bookings are made. To check, whether credentials are currently stored and still valid (they can expire), you can use the \nregion.linkedAccounts()\n helper above.\n\n\nFor unlinking an account again there's another helper:\n\n\nregion.unlinkAccount(mode, remoteURL: auth.actionURL) { success in\n  // Do something\n}\n\n\n\n\nNote that the helper for unlinking, only requires the \nactionURL\n when the OAuth credentials have been associated with the user's account. Unlinking removes credentials stored locally and those associated with the user's account.\n\n\n\n\nGetting available TSP products for a trip\n\n\nAvailable TSP products for a trip are associated with a segment. The information about these products is not included in the standard routing responses, but needs to be fetched separately.\n\n\nWhether such TSP products are available, is indicated by the segment having a \nbookingQuickInternalURL\n. If that URL exists, the \nTKQuickBookingHelper\n can then fetch all the available products:\n\n\nTKQuickBookingHelper.fetchQuickBookings(forSegment: segment) { quickBookings in\n  // Update UI\n}\n\n\n\n\nNote\n: Fetching this information does typically not require the user to have linked their account with the TSP of that segment.\n\n\nEach of these come with a variety of information about the product, possibly including information on the price or ETA.\n\n\nThe two main actions that you can take with these details are:\n\n\n\n\nUpdate the trip with the product, using the \ntripUpdateURL\n (see below for details). This is useful if you need the trip's properties to reflect the price and ETA of the selected product.\n\n\nBook the product, the using \nbookingURL\n (see below for details).\n\n\n\n\n\n\nBooking a segment\n\n\nUsers can book trip on a segment-by-segment basis. The booking requires the \nbookingURL\n for the specific product that the user wants to book as mentioned in the previous section.\n\n\nTripKit iOS has a helper method \nBPKOperator.makeBookingToURL/2\n which then initiates the booking:\n\n\nlet mode = segment.modeIdentifier()\nBPKOperator.makeBookingToURL(mode, URL: bookingURL)\n  .subscribe { event in\n    switch event {\n    case .Next(.UpdateTrip(let url)):\n      // Booking went through. Update the trip (see below).\n    case .Next(.LoadForm(let form)):\n      // More information required.\n      // Display booking form using `BPKBookingViewController`\n    case .Next(.ShowAgreement(let displayUrl, let discardUrl))\n      // User confirmation required.\n    case .Error(let error):\n      // Handle error\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n}\n\n\n\n\nThis method does a handful of things:\n\n\n\n\nIt checks whether the user has already linked their account for the provider of the segment (the credentials are linked to the segment's mode, which is why the method takes the \nmode\n parameter).\n\n\nIf the user's account has not been linked, the \nBPKOperator\n will start the OAuth process described \nin the section on linking accounts\n.\n\n\nIf the user's account has already been linked, those credentials will be used.\n\n\nIf there's an error during this process, then observable aborts with an error.\n\n\n\n\n\n\nAn attempt to make the booking is performed, which can have the following outcomes:\n\n\nThe booking was successful and \nBookingResult.UpdateTrip\n is returned with a URL to update the trip, which will then include the confirmation details.\n\n\nThe booking can be made, but more information is required by the user. This is the case \nBookingResult.LoadTrip\n which returns a booking form, which can be then be displayed using the \nBPKBookingViewController\n.\n\n\nThe booking can be made, but the user first need to accept an agreement. This is the case \n`BookingResult.UpdateTrip\n which returns two URLs. The first URL should be displayed to the user, and the user has accepted the terms once the user gets to the second URL. If the user accepted, you should then kick off the initial call to \nBPKOperator.makeBookingToURL\n again.\n\n\nIf there's an error, the observable aborts with an error.\n\n\n\n\n\n\n\n\n\n\nUpdating trip with booking details / confirmation\n\n\nAs described above, the booking process provides URLs to fetch an update of the trip. This can be used to update a trip with a selected TSP process, and also to fetch the booking status of a trip.\n\n\nThis process is the same as updating a trip with real-time data, e.g.:\n\n\nlet router = TKBuzzRouter()\nlet context = TKTripKit.sharedInstance().tripKitContext\nrouter.downloadTrip(url, intoTripKitContext: context) { updatedTrip in\n  if let updatedTrip = updatedTrip {\n    let request = originalTrip.request\n    originalTrip.removeFromRequest()\n    updatedTrip.moveToRequest(request, markAsPreferred: true)\n  }\n}\n\n\n\n\nNoteworthy is here, the \nsegment.bookingConfirmation\n property provided by \nTKQuickBookingHelper\n which returns a \nTKBookingConfirmation\n struct after a booking has been made. This struct includes:\n\n\n\n\nstatus\n: A title and optional description describing the current status of the trip.\n\n\nInformation on the \nprovider\n and \nvehicle\n servicing this booking. Note that these can be missing; typically while the booking is still being processed by the TSP, in the cast that it has been cancelled, or also after the trip has been completed.\n\n\nA list of actions, such as calling the provider or cancelling the booking.", 
            "title": "Bookings (iOS)"
        }, 
        {
            "location": "/enterprise/bookings-ios/#bookings-in-tripkit-ios", 
            "text": "Note: Enterprise customers-only  Note: Beta-only  TripKit iOS supports all the booking API endpoints, including handling the OAuth process. OAuth credentials are stored securely in the device's keychain and, optionally, linked to the user's account.", 
            "title": "Bookings in TripKit iOS"
        }, 
        {
            "location": "/enterprise/bookings-ios/#preparations", 
            "text": "To get started, configured your project as follows:   Include  BookingKit  from  shared-ios , including all its dependencies.  Include  tripkit-ios  as a dependency, including its  Bookings  add-on.  Add the  OAuthCallbackURL  to your  Config.plist  configuration file.  Make sure your app has the URL scheme from that callback URL registered.   Next, you need to respond to calls to that  OAuthCallbackURL  in your application delegate by implementing  application(openURL:options)  (or its deprecated precursors), and handling the calls similar to this:  let OAuthCallbackURL = SGKConfig.sharedIntance().oauthCallbackURL()\nif (URL.absoluteString.hasPrefix(OAuthCallbackURL.absoluteString)) {\n  OAuthSwift.handleOpenURL(URL)\n  return true\n}", 
            "title": "Preparations"
        }, 
        {
            "location": "/enterprise/bookings-ios/#linking-and-unlinking-accounts", 
            "text": "You can then which accounts are available for linking for a given region:  let region = SVKRegionManager.sharedInstance().regionWithName(...)\nregion.linkedAccounts() { auths in\n  for auth in auths {\n    if auth.isConnected {\n      // Update UI and allow unlinking\n    } else {\n      // Update UI and allow linking\n    }\n  }\n}  This both checks which modes can be associated with an account, and also whether the credentials are already available. Credentials are available when they are either stored locally or associated with the user's account,  and  they have not expired.  To kick of linking, which saves the credentials locally and to the user's account (if the user is logged in), there's a helper based on  RxSwift :  region.rx_linkAccount(mode, remoteURL: auth.actionURL)\n  .subscribe { event in\n    switch event {\n    case .Next(let success):\n      // Account has been linked. Update the UI.\n    case .Error(let error):\n      // Account could not get linked. Handle error.\n      print(error)\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)  Note that this helper requires the  actionURL  as this is used to fetch what information is necessary for the OAuth flow for the provider servicing the specified  mode :  These credentials will then be used automatically later on when bookings are made. To check, whether credentials are currently stored and still valid (they can expire), you can use the  region.linkedAccounts()  helper above.  For unlinking an account again there's another helper:  region.unlinkAccount(mode, remoteURL: auth.actionURL) { success in\n  // Do something\n}  Note that the helper for unlinking, only requires the  actionURL  when the OAuth credentials have been associated with the user's account. Unlinking removes credentials stored locally and those associated with the user's account.", 
            "title": "Linking and unlinking accounts"
        }, 
        {
            "location": "/enterprise/bookings-ios/#getting-available-tsp-products-for-a-trip", 
            "text": "Available TSP products for a trip are associated with a segment. The information about these products is not included in the standard routing responses, but needs to be fetched separately.  Whether such TSP products are available, is indicated by the segment having a  bookingQuickInternalURL . If that URL exists, the  TKQuickBookingHelper  can then fetch all the available products:  TKQuickBookingHelper.fetchQuickBookings(forSegment: segment) { quickBookings in\n  // Update UI\n}  Note : Fetching this information does typically not require the user to have linked their account with the TSP of that segment.  Each of these come with a variety of information about the product, possibly including information on the price or ETA.  The two main actions that you can take with these details are:   Update the trip with the product, using the  tripUpdateURL  (see below for details). This is useful if you need the trip's properties to reflect the price and ETA of the selected product.  Book the product, the using  bookingURL  (see below for details).", 
            "title": "Getting available TSP products for a trip"
        }, 
        {
            "location": "/enterprise/bookings-ios/#booking-a-segment", 
            "text": "Users can book trip on a segment-by-segment basis. The booking requires the  bookingURL  for the specific product that the user wants to book as mentioned in the previous section.  TripKit iOS has a helper method  BPKOperator.makeBookingToURL/2  which then initiates the booking:  let mode = segment.modeIdentifier()\nBPKOperator.makeBookingToURL(mode, URL: bookingURL)\n  .subscribe { event in\n    switch event {\n    case .Next(.UpdateTrip(let url)):\n      // Booking went through. Update the trip (see below).\n    case .Next(.LoadForm(let form)):\n      // More information required.\n      // Display booking form using `BPKBookingViewController`\n    case .Next(.ShowAgreement(let displayUrl, let discardUrl))\n      // User confirmation required.\n    case .Error(let error):\n      // Handle error\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n}  This method does a handful of things:   It checks whether the user has already linked their account for the provider of the segment (the credentials are linked to the segment's mode, which is why the method takes the  mode  parameter).  If the user's account has not been linked, the  BPKOperator  will start the OAuth process described  in the section on linking accounts .  If the user's account has already been linked, those credentials will be used.  If there's an error during this process, then observable aborts with an error.    An attempt to make the booking is performed, which can have the following outcomes:  The booking was successful and  BookingResult.UpdateTrip  is returned with a URL to update the trip, which will then include the confirmation details.  The booking can be made, but more information is required by the user. This is the case  BookingResult.LoadTrip  which returns a booking form, which can be then be displayed using the  BPKBookingViewController .  The booking can be made, but the user first need to accept an agreement. This is the case  `BookingResult.UpdateTrip  which returns two URLs. The first URL should be displayed to the user, and the user has accepted the terms once the user gets to the second URL. If the user accepted, you should then kick off the initial call to  BPKOperator.makeBookingToURL  again.  If there's an error, the observable aborts with an error.", 
            "title": "Booking a segment"
        }, 
        {
            "location": "/enterprise/bookings-ios/#updating-trip-with-booking-details-confirmation", 
            "text": "As described above, the booking process provides URLs to fetch an update of the trip. This can be used to update a trip with a selected TSP process, and also to fetch the booking status of a trip.  This process is the same as updating a trip with real-time data, e.g.:  let router = TKBuzzRouter()\nlet context = TKTripKit.sharedInstance().tripKitContext\nrouter.downloadTrip(url, intoTripKitContext: context) { updatedTrip in\n  if let updatedTrip = updatedTrip {\n    let request = originalTrip.request\n    originalTrip.removeFromRequest()\n    updatedTrip.moveToRequest(request, markAsPreferred: true)\n  }\n}  Noteworthy is here, the  segment.bookingConfirmation  property provided by  TKQuickBookingHelper  which returns a  TKBookingConfirmation  struct after a booking has been made. This struct includes:   status : A title and optional description describing the current status of the trip.  Information on the  provider  and  vehicle  servicing this booking. Note that these can be missing; typically while the booking is still being processed by the TSP, in the cast that it has been cancelled, or also after the trip has been completed.  A list of actions, such as calling the provider or cancelling the booking.", 
            "title": "Updating trip with booking details / confirmation"
        }
    ]
}