{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TripGo API The TripGo API allows you to plan door-to-door trips using a large variety of public and private transport. It integrates real-time information and, for selected providers, allows users to book and pay for transport. Getting started 1. Getting an API key Get an API key . You can try it out for free for as long as you like, as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the SkedGo website . It may take up to 5 minutes for your key to be active. Once you have an API key, send it along with every request as the X-TripGo-Key header. 2. Make a request Our API can do a lot more than just directions , but if that is what you are interested in, then try something like: curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.863,151.208)&departAfter=1532799914&modes[]=wa_wal&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g or curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.891,151.209)&modes[]=pt_pub&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g Keep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further in the F.A.Q. . 3. Where to go from here? If you're an app developer, take a look at our open source TripKit SDKs for iOS, macOS and Android . If you're a web developer, take a look at our sample app \"FastGo\" and its accompanying blog post series , or check out our Leaflet Plugin (see Demo ). If you're a backend developer, dive into the API specs , which are available in OpenAPI (formerly Swagger) format. If you know how to debug a web app, look at the network activity for our web app to get an idea of which API calls to use when. (Filter for \"satapp\".) To talk to us and other developers using our API, join our Slack team by self-invite .","title":"Getting Started"},{"location":"#tripgo-api","text":"The TripGo API allows you to plan door-to-door trips using a large variety of public and private transport. It integrates real-time information and, for selected providers, allows users to book and pay for transport.","title":"TripGo API"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#1-getting-an-api-key","text":"Get an API key . You can try it out for free for as long as you like, as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the SkedGo website . It may take up to 5 minutes for your key to be active. Once you have an API key, send it along with every request as the X-TripGo-Key header.","title":"1. Getting an API key"},{"location":"#2-make-a-request","text":"Our API can do a lot more than just directions , but if that is what you are interested in, then try something like: curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.863,151.208)&departAfter=1532799914&modes[]=wa_wal&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g or curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.891,151.209)&modes[]=pt_pub&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g Keep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further in the F.A.Q. .","title":"2. Make a request"},{"location":"#3-where-to-go-from-here","text":"If you're an app developer, take a look at our open source TripKit SDKs for iOS, macOS and Android . If you're a web developer, take a look at our sample app \"FastGo\" and its accompanying blog post series , or check out our Leaflet Plugin (see Demo ). If you're a backend developer, dive into the API specs , which are available in OpenAPI (formerly Swagger) format. If you know how to debug a web app, look at the network activity for our web app to get an idea of which API calls to use when. (Filter for \"satapp\".) To talk to us and other developers using our API, join our Slack team by self-invite .","title":"3. Where to go from here?"},{"location":"extensions/","text":"Extensions Right after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system. The TripGo API can be extended in the following ways: Unlock transport modes, regions and real-time data from services that require you to first accept their terms or acquire API credentials. Add new transport modes through our TSP Connectors (coming soon). Add new regions through our Region Connectors (coming soon). Unlocking transport modes To get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). BlaBlaCar \ud83c\udf0d Integrations : Routing, Real-time Read the terms of use of BlaBlaCar's API and make sure you comply with them in your app. Sign up to BlaBlaCar's API . Enter your BlaBlaCar auth key in your application credentials . BlaBlaCar results will start coming through the TripGo API for your API key (after at most 5 minutes). Car2go \ud83c\udf0f Integrations : Locations, Routing, Real-time, Bookings Read the terms of use of the car2go API and make sure you comply with them in your app. Mail openapi@car2go.com as described in there. Enter your Car2go consumerKey in your application credentials . Car2go results will start coming through the TripGo API for your API key (after at most 5 minutes). Flinkster \ud83c\uddea\ud83c\uddfa Integrations : Locations, Routing, Real-time Sign up to Deutsche Bahn's Flinkster API Login to Deutsche Bahn's developer website, select \"My Subscriptions\" and generate an \"Access Token\" Enter this as your Flinkster access token in your application credentials . Flinkster results will start coming through the TripGo API for your API key (after at most 5 minutes). Flit \ud83c\udf0e Integrations : Routing, Real-time Get in touch with Flit and get access to their API . Enter your Flit api key in your application credentials . Flit results will start coming through the TripGo API for your API key (after at most 5 minutes). GoGet \ud83c\udde6\ud83c\uddfa Integrations : Locations, Routing, Real-time Get in touch with GoGet 's sales team and get access to their API. Enter your GoGet ConsumerKey and GoGet ConsumerSecret in your application credentials . GoGet results will start coming through the TripGo API for your API key (after at most 5 minutes). Lyft \ud83c\uddfa\ud83c\uddf8 Integrations : Routing, Real-time, Bookings Read the terms of use of Lyft's API and make sure you comply with them in your app. Sign up to Lyft's API . Enter your Lyft Client ID and Lyft Client Secret in your application credentials . Lyft results will start coming through the TripGo API for your API key (after at most 5 minutes). MyDriver \ud83c\udf0e Integrations : Routing, Real-time Get in touch with MyDriver 's sales team and get access to their API. Enter your MyDriver username and MyDriver password in your application credentials . MyDriver results will start coming through the TripGo API for your API key (after at most 5 minutes). Ola \ud83c\uddee\ud83c\uddf3 \ud83c\udde6\ud83c\uddfa \ud83c\uddf3\ud83c\uddff \ud83c\uddec\ud83c\udde7 Integrations : Routing, Real-time Get in touch with Ola 's sales team and get access to their API. Enter your OLA ApiKey in your application credentials . Ola results will start coming through the TripGo API for your API key (after at most 5 minutes). Uber \ud83c\udf0e Integrations : Routing, Real-time, Bookings Read the terms of use of Uber's API and make sure you comply with them in your app. Sign up to Uber's ride request API . Enter your Uber client ID , Uber client secret and Uber server token in your application credentials . Uber results will start coming through the TripGo API for your API key (after at most 5 minutes). Zipcar \ud83c\uddfa\ud83c\uddf8 Integrations : Locations, Routing, Real-time Get in touch with Zipcar and get access to their API. Enter your Zipcar API key in your application credentials . Zipcar results will start coming through the TripGo API for your API key (after at most 5 minutes). Unlocking real-time data To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Live-Traffic from Google \ud83c\udf0e Read the terms of use of Google Maps and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Maps Directions API Enter your Google Maps Directions API key in your application credentials . Car results leaving now will then come augmented with Google's drive time predictions through the TripGo API for your API key (after at most 5 minutes). Live-Traffic from TomTom \ud83c\udf0e Sign up to the TomTom Maps API , making sure you read the terms and comply with them - in particular, that you're not affiliated with a prohibited party and that you're using a TomTom or TomTom licenses map UI (e.g., Apple Maps). Enter your TomTom consumer API key and TomTom consumer secret in your application credentials . Car results leaving now will then come augmented with TomTom's drive time predictions through the TripGo API for your API key (after at most 5 minutes). Chicago's CTA \ud83c\uddfa\ud83c\uddf8 Read the terms of use of CTA's API and make sure you comply with them in your app Sign up to CTA's API Enter your CTA key for Chicago in your application credentials . Real-time data for CTA for your TripGo API key will be enabled (after at most 5 minutes). Unlocking geocoding providers To get results from geocoding data for providers who aren't using Open Data when using geocoding.json endpoint, follow the instructions for the provider below. These providers will only apply for non auto-completion requests, except for What3Words ones, which can be used for both type of geocoding requests. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Foursquare \ud83c\udf0e Read the Foursquare Terms of Use and make sure you comply with them in your app. Sign up to the Foursquare Developers Site Enter your Foursquare API key in your application credentials . Add allowFoursquare=true to your geocoding requests, and then geocoding results will then come augmented with Foursquare's API through the TripGo API for your API key (after at most 5 minutes). Google Places \ud83c\udf0e Read the Places API Policies and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Places API Enter your Google Places API key in your application credentials . Add allowGoogle=true to your geocoding requests, and then geocoding results will then come augmented with Google Places's API through the TripGo API for your API key (after at most 5 minutes). What3Words \ud83c\udf0e Read the API Licence Agreement and make sure you comply with them in your app. Sign up to the What3Words API Enter your What 3 Words key in your application credentials . Add allowW3W=true to your geocoding requests, and then geocoding results will then come augmented with What3Words's API through the TripGo API for your API key (after at most 5 minutes). Yelp \ud83c\udf0e Read the Yelp Terms of Use and make sure you comply with them in your app. Sign up to the Yelp Developers Site Enter your Yelp API key in your application credentials . Add allowYelp=true to your geocoding requests, and then geocoding results will then come augmented with Yelp's API through the TripGo API for your API key (after at most 5 minutes). Unlocking regions To get results for regions with providers that aren't using Open Data, or which we haven't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Rio de Janeiro (Brazil) \ud83c\udf0e Go to Fetransport Site and make sure you agree with the data terms. Contact us if you need help for this. Forward your confirmation mail to api@skedgo.com We will then unlock the region for your API key.","title":"Extensions"},{"location":"extensions/#extensions","text":"Right after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system. The TripGo API can be extended in the following ways: Unlock transport modes, regions and real-time data from services that require you to first accept their terms or acquire API credentials. Add new transport modes through our TSP Connectors (coming soon). Add new regions through our Region Connectors (coming soon).","title":"Extensions"},{"location":"extensions/#unlocking-transport-modes","text":"To get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking transport modes"},{"location":"extensions/#blablacar","text":"Integrations : Routing, Real-time Read the terms of use of BlaBlaCar's API and make sure you comply with them in your app. Sign up to BlaBlaCar's API . Enter your BlaBlaCar auth key in your application credentials . BlaBlaCar results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"BlaBlaCar \ud83c\udf0d"},{"location":"extensions/#car2go","text":"Integrations : Locations, Routing, Real-time, Bookings Read the terms of use of the car2go API and make sure you comply with them in your app. Mail openapi@car2go.com as described in there. Enter your Car2go consumerKey in your application credentials . Car2go results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Car2go \ud83c\udf0f"},{"location":"extensions/#flinkster","text":"Integrations : Locations, Routing, Real-time Sign up to Deutsche Bahn's Flinkster API Login to Deutsche Bahn's developer website, select \"My Subscriptions\" and generate an \"Access Token\" Enter this as your Flinkster access token in your application credentials . Flinkster results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Flinkster \ud83c\uddea\ud83c\uddfa"},{"location":"extensions/#flit","text":"Integrations : Routing, Real-time Get in touch with Flit and get access to their API . Enter your Flit api key in your application credentials . Flit results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Flit \ud83c\udf0e"},{"location":"extensions/#goget","text":"Integrations : Locations, Routing, Real-time Get in touch with GoGet 's sales team and get access to their API. Enter your GoGet ConsumerKey and GoGet ConsumerSecret in your application credentials . GoGet results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"GoGet \ud83c\udde6\ud83c\uddfa"},{"location":"extensions/#lyft","text":"Integrations : Routing, Real-time, Bookings Read the terms of use of Lyft's API and make sure you comply with them in your app. Sign up to Lyft's API . Enter your Lyft Client ID and Lyft Client Secret in your application credentials . Lyft results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Lyft \ud83c\uddfa\ud83c\uddf8"},{"location":"extensions/#mydriver","text":"Integrations : Routing, Real-time Get in touch with MyDriver 's sales team and get access to their API. Enter your MyDriver username and MyDriver password in your application credentials . MyDriver results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"MyDriver \ud83c\udf0e"},{"location":"extensions/#ola","text":"Integrations : Routing, Real-time Get in touch with Ola 's sales team and get access to their API. Enter your OLA ApiKey in your application credentials . Ola results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Ola \ud83c\uddee\ud83c\uddf3 \ud83c\udde6\ud83c\uddfa \ud83c\uddf3\ud83c\uddff \ud83c\uddec\ud83c\udde7"},{"location":"extensions/#uber","text":"Integrations : Routing, Real-time, Bookings Read the terms of use of Uber's API and make sure you comply with them in your app. Sign up to Uber's ride request API . Enter your Uber client ID , Uber client secret and Uber server token in your application credentials . Uber results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Uber \ud83c\udf0e"},{"location":"extensions/#zipcar","text":"Integrations : Locations, Routing, Real-time Get in touch with Zipcar and get access to their API. Enter your Zipcar API key in your application credentials . Zipcar results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Zipcar \ud83c\uddfa\ud83c\uddf8"},{"location":"extensions/#unlocking-real-time-data","text":"To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking real-time data"},{"location":"extensions/#live-traffic-from-google","text":"Read the terms of use of Google Maps and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Maps Directions API Enter your Google Maps Directions API key in your application credentials . Car results leaving now will then come augmented with Google's drive time predictions through the TripGo API for your API key (after at most 5 minutes).","title":"Live-Traffic from Google \ud83c\udf0e"},{"location":"extensions/#live-traffic-from-tomtom","text":"Sign up to the TomTom Maps API , making sure you read the terms and comply with them - in particular, that you're not affiliated with a prohibited party and that you're using a TomTom or TomTom licenses map UI (e.g., Apple Maps). Enter your TomTom consumer API key and TomTom consumer secret in your application credentials . Car results leaving now will then come augmented with TomTom's drive time predictions through the TripGo API for your API key (after at most 5 minutes).","title":"Live-Traffic from TomTom \ud83c\udf0e"},{"location":"extensions/#chicagos-cta","text":"Read the terms of use of CTA's API and make sure you comply with them in your app Sign up to CTA's API Enter your CTA key for Chicago in your application credentials . Real-time data for CTA for your TripGo API key will be enabled (after at most 5 minutes).","title":"Chicago's CTA \ud83c\uddfa\ud83c\uddf8"},{"location":"extensions/#unlocking-geocoding-providers","text":"To get results from geocoding data for providers who aren't using Open Data when using geocoding.json endpoint, follow the instructions for the provider below. These providers will only apply for non auto-completion requests, except for What3Words ones, which can be used for both type of geocoding requests. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking geocoding providers"},{"location":"extensions/#foursquare","text":"Read the Foursquare Terms of Use and make sure you comply with them in your app. Sign up to the Foursquare Developers Site Enter your Foursquare API key in your application credentials . Add allowFoursquare=true to your geocoding requests, and then geocoding results will then come augmented with Foursquare's API through the TripGo API for your API key (after at most 5 minutes).","title":"Foursquare \ud83c\udf0e"},{"location":"extensions/#google-places","text":"Read the Places API Policies and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Places API Enter your Google Places API key in your application credentials . Add allowGoogle=true to your geocoding requests, and then geocoding results will then come augmented with Google Places's API through the TripGo API for your API key (after at most 5 minutes).","title":"Google Places \ud83c\udf0e"},{"location":"extensions/#what3words","text":"Read the API Licence Agreement and make sure you comply with them in your app. Sign up to the What3Words API Enter your What 3 Words key in your application credentials . Add allowW3W=true to your geocoding requests, and then geocoding results will then come augmented with What3Words's API through the TripGo API for your API key (after at most 5 minutes).","title":"What3Words \ud83c\udf0e"},{"location":"extensions/#yelp","text":"Read the Yelp Terms of Use and make sure you comply with them in your app. Sign up to the Yelp Developers Site Enter your Yelp API key in your application credentials . Add allowYelp=true to your geocoding requests, and then geocoding results will then come augmented with Yelp's API through the TripGo API for your API key (after at most 5 minutes).","title":"Yelp \ud83c\udf0e"},{"location":"extensions/#unlocking-regions","text":"To get results for regions with providers that aren't using Open Data, or which we haven't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking regions"},{"location":"extensions/#rio-de-janeiro-brazil","text":"Go to Fetransport Site and make sure you agree with the data terms. Contact us if you need help for this. Forward your confirmation mail to api@skedgo.com We will then unlock the region for your API key.","title":"Rio de Janeiro (Brazil) \ud83c\udf0e"},{"location":"faq/","text":"General Languages Which languages does the API support? Most text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish. The translations are done in the open on Crowdin and everyone can contribute, including adding new languages. One note of causion: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them. Regions What are regions? Our API splits the world into several pieces, which we call regions. Several endpoints require you to pass along a region code, e.g., because identifiers might be duplicated around the world. You can get a list of regions by quering regions.json : curl 'https://api.tripgo.com/v1/regions.json' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -d '{\"v\":2}' Then extract the polylines from there and match your coordinates to a region. This endpoint also tells you which modes are supported by routing for a given region. I noticed URLs in those regions, how can/should I use those? Most developer should not need to worry about these and can just use the api.tripgo.com domain. However, performance critical application can use this to reduce lag and directly hit the routing servers. For advanced users : This exposes to you that our API is covered by multiple servers - though not every server covers ever region. You can use the URLs to directly query servers covering a certain region \u2013 which can be beneficial to reduce lag and is recommended for server-to-server communication. However, be aware that you should add failover from one server to another yourself then, as individual servers can go down unannounced for maintenance. You should only cache this information short term as those URLs can change without notice. Map Data Which Map Data Layer do you use? Our platform uses OSM ( Open Street Map ) for the underlying map data, and this information is used when we calculate routes (mainly for private transport modes). This data affects, for example, how we decide what routes are faster, the shapes of the resulting trips for roads, paths and cycleways, among others. We can also integrate other data layers (such as Here ) upon request. If you want to use other data layer than OSM, please get in touch with our team by mail or on Slack (by self-invite ). But I see Google Maps in TripGo apps TripGo Android app and our web app use Google Maps to display information on the map, whereas the TripGo iOS app uses Apple Maps . Note, however, that this is different from the map data used by the platform to calculate routes. Google or Apple Maps are the visual map used by front-end apps to display trips and locations to the end user. It is up to the front-ends to decide which mapping UI SDK to use. It is important to note that different mapping UIs may have restrictions in their licensing terms which other APIs and services can be used to display on and alongside those maps. Routing Mode Identifiers What are all these peculiar looking strings such as pt_pub ? Syntax The syntax of the mode string is like this: <group>_<mode that makes sense to the user>[_<provider or fine-grained mode>] List of groups pt_ is for transit which runs on schedules ps_ is for taxi-like on-demand services me_ is for vehicles you drive yourself cy_ is for cycling wa_ is for walking in_ is for intercity long distance transport pt_ pt_pub is \"public transit\" that is accessible to public pt_pub_bus pt_pub_train pt_pub_ferry pt_pub_tram pt_pub_subway pt_pub_monorail pt_pub_cablecar pt_pub_funicular pt_pub_gondola pt_ltd_SCHOOLBUS is public transit of limited access (school buses) ps_ ps_tax is for taxis ps_tnc is for uber and alike (TNC is California's official code for them) ps_tnc_lyft ps_tnc_sidecar ps_tnc_uber ps_shu is for (airport) shuttles me_ me_car is for your own car me_car-s is for car sharing (like ZipCar or GoGet) me_car-r is for car rental (like Budget) me_car-p is for car pooling (like BlaBlaCar) me_mot is for your own motorbike Single-modal vs. multi-modal routing How do I get these sweet results which combine taxis or other private transport modes with public transport? You need to specify multiple modes in the routing.json requests, e.g., by using modes=pt_pub&modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those. What if I want to get both public-transport-only results and mixed results? In this case you need to currently send off multiple requests, e.g., if you want public transport, taxi, and combinations of the two, you need to send three requests: one with modes=pt_pub , one with modes=ps_tax , and one with modes=pt_pub&modes=ps_tax . The request with multiple modes will only return inter-modal results, no results for individual modes. A few things to note about this: This is done as inter-modal results can be slower to calculate due to the many combinations to crunch and them being likely to depend on external API calls, slowing things down further. By having the inter-modal request not returning single-modal results, you don't need to do any duplicate detection between the results of the different calls as they are mutually exclusive. You'll only get such inter-modal combinations where that combination is better in some way than using any individual mode by itself. It is therefore quite common that inter-modal requests result in an empty response. Trips, groups, frequencies and templates What is the logic behind trip groups and what does the frequency property mean? Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times. Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group. In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest weightedScore . Why are segments split into references and templates? This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client. Trips results Why do I get trips with the first segment of a trip already in the past? When you have a trip group, you will get trips departing before the best one matching the query. What you should do is, grey it out in the UI and don't select it by default (the weighted score is a good indicator for this). Note that you can even get a trip group only with a trip in the past, e.g., if you queried for 12:15am and the last ferry left at 12:10. Why do I get trips having segments that \"go back in time\" and result in arriving after the depart of the next one? There may be cases where a segment of a trip is delayed, and due to realtime updates, the trip gets negative waiting times, e.g., a bus is delayed by 5 minutes and the trip had a connection of 2 minutes to take a train. These cases should be handled by the app, either by alerting the user, by recomputing the trip, or by any other measure you consider appropriate. Placeholders in segment templates What are all the possible values for placeholders and how should they get interpreted? In order to use segment templates for multiple similar segments, the notes and action fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data. <NUMBER> : Placeholder for the number of short name of the transit service, e.g., segment.serviceNumber . <LINE_NAME> : Placeholder for the long name of the transit service, e.g., segment.serviceName . <DIRECTION> : Placeholder for the direction of the transit service, e.g., segment.serviceDirection . <LOCATIONS> : Placeholder for the start and end location of the segment, e.g., segment.start -> segment.end . <PLATFORM> : Placeholder for the embarkation platform of the transit service, e.g., segment.platform . <STOPS> : Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g., segment.stops . <TIME> *: Placeholder for the departure time of the segment, e.g., segment.startTime formatted as a time. Note that this can directly follow a <NUMBER> template, so you might have to add spacing. <DURATION> *: Placeholder for the total duration of the segment, e.g., segment.endTime - segment.startTime formatted as a duration string. <TRAFFIC> : (Badly named) placeholder for the total duration without traffic of the segment, e.g., segment.durationWithoutTraffic formatted as a duration string. * : Should be updated with real-time data. Advanced Routing Features How does wheelchair flag in true affect the resulting trips? There are three possible scenarios for public services, public stops, and paths: we know they are wheelchair accessible, we know they are not wheelchair accessible, or we don't have information about them. When the wheelchair flag is on, our routing engine will try to avoid services, stops and paths that are known by us to be inaccessible. In addition, we'll change 'walking' instructions to 'rolling' instructions, and indicate which sections are accessible, inaccessible or unknown. What's the action field in the alerts for? Sometimes we get real-time data that may change the accessibility status for public stops, for example when a lift is temporarily out of service in a train station. In these cases, we provide a mechanism that allows to identify the problem and send a re-route request specifically asking to avoid the stop(s) that have become inaccessible. If the embark/disembark stop of a public segment has issues, then we'll associate that segment with an alert describing the issue and containing a special action field of type rerouteExcludingStops which provides a list of the affected stop codes. Then if you want to get a new set of results avoiding those stops, you can add the avoidStops parameter to your original routing request, using the stop codes provided in the alert action field, and re-send it. Note that this new request will only avoid the stops you specifically indicated with the avoidStops parameter, so your new set of results may again include an alert for a different stop that also has issues. So you may want to send a third request asking to avoid this one too, but it's important that you include all of them in the avoidStops list, or otherwise you'll get again the stops that were first excluded. Locations Locations, cell IDs and hash codes What are the cell IDs in the locations.json endpoint? The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as $(lat*cellsPerDegree)#$(lng*cellsPerDegree) . Got it. And cellIDHashCodes ? You typically call locations.json with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use cellIDHashCodes as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed. Example Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request: { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDs\": [ \"-2540#11339\", \"-2540#11340\", \"-2540#11341\", \"-2541#11339\", \"-2541#11340\", \"-2541#11341\", \"-2542#11339\", \"-2542#11340\", \"-2542#11341\" ] } You'll then get results: { \"groups\": [ { \"hashCode\": 690784261, \"key\": \"-2540#11339\", \"stops\": [...] }, { \"hashCode\": -1940969928, \"key\": \"-2540#11340\", \"stops\": [...] } ] } You can then cache these and later on request again for changes by supplying cellIDHashCodes : { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDHashCodes\": { \"-2540#11339\": 690784261, \"-2540#11340\": -1940969928 } } Which will then only return any groups that have changed. If nothing changed, you'll just get back: { \"groups\": [] } Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself: { \"region\": \"AU_NSW_Sydney\", \"cellIDHashCodes\": { \"AU_NSW_Sydney\": 1096794422 } }","title":"F.A.Q."},{"location":"faq/#general","text":"","title":"General"},{"location":"faq/#languages","text":"Which languages does the API support? Most text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish. The translations are done in the open on Crowdin and everyone can contribute, including adding new languages. One note of causion: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them.","title":"Languages"},{"location":"faq/#regions","text":"What are regions? Our API splits the world into several pieces, which we call regions. Several endpoints require you to pass along a region code, e.g., because identifiers might be duplicated around the world. You can get a list of regions by quering regions.json : curl 'https://api.tripgo.com/v1/regions.json' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -d '{\"v\":2}' Then extract the polylines from there and match your coordinates to a region. This endpoint also tells you which modes are supported by routing for a given region. I noticed URLs in those regions, how can/should I use those? Most developer should not need to worry about these and can just use the api.tripgo.com domain. However, performance critical application can use this to reduce lag and directly hit the routing servers. For advanced users : This exposes to you that our API is covered by multiple servers - though not every server covers ever region. You can use the URLs to directly query servers covering a certain region \u2013 which can be beneficial to reduce lag and is recommended for server-to-server communication. However, be aware that you should add failover from one server to another yourself then, as individual servers can go down unannounced for maintenance. You should only cache this information short term as those URLs can change without notice.","title":"Regions"},{"location":"faq/#map-data","text":"Which Map Data Layer do you use? Our platform uses OSM ( Open Street Map ) for the underlying map data, and this information is used when we calculate routes (mainly for private transport modes). This data affects, for example, how we decide what routes are faster, the shapes of the resulting trips for roads, paths and cycleways, among others. We can also integrate other data layers (such as Here ) upon request. If you want to use other data layer than OSM, please get in touch with our team by mail or on Slack (by self-invite ). But I see Google Maps in TripGo apps TripGo Android app and our web app use Google Maps to display information on the map, whereas the TripGo iOS app uses Apple Maps . Note, however, that this is different from the map data used by the platform to calculate routes. Google or Apple Maps are the visual map used by front-end apps to display trips and locations to the end user. It is up to the front-ends to decide which mapping UI SDK to use. It is important to note that different mapping UIs may have restrictions in their licensing terms which other APIs and services can be used to display on and alongside those maps.","title":"Map Data"},{"location":"faq/#routing","text":"","title":"Routing"},{"location":"faq/#mode-identifiers","text":"What are all these peculiar looking strings such as pt_pub ?","title":"Mode Identifiers"},{"location":"faq/#syntax","text":"The syntax of the mode string is like this: <group>_<mode that makes sense to the user>[_<provider or fine-grained mode>]","title":"Syntax"},{"location":"faq/#list-of-groups","text":"pt_ is for transit which runs on schedules ps_ is for taxi-like on-demand services me_ is for vehicles you drive yourself cy_ is for cycling wa_ is for walking in_ is for intercity long distance transport","title":"List of groups"},{"location":"faq/#pt_","text":"pt_pub is \"public transit\" that is accessible to public pt_pub_bus pt_pub_train pt_pub_ferry pt_pub_tram pt_pub_subway pt_pub_monorail pt_pub_cablecar pt_pub_funicular pt_pub_gondola pt_ltd_SCHOOLBUS is public transit of limited access (school buses)","title":"pt_"},{"location":"faq/#ps_","text":"ps_tax is for taxis ps_tnc is for uber and alike (TNC is California's official code for them) ps_tnc_lyft ps_tnc_sidecar ps_tnc_uber ps_shu is for (airport) shuttles","title":"ps_"},{"location":"faq/#me_","text":"me_car is for your own car me_car-s is for car sharing (like ZipCar or GoGet) me_car-r is for car rental (like Budget) me_car-p is for car pooling (like BlaBlaCar) me_mot is for your own motorbike","title":"me_"},{"location":"faq/#single-modal-vs-multi-modal-routing","text":"How do I get these sweet results which combine taxis or other private transport modes with public transport? You need to specify multiple modes in the routing.json requests, e.g., by using modes=pt_pub&modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those. What if I want to get both public-transport-only results and mixed results? In this case you need to currently send off multiple requests, e.g., if you want public transport, taxi, and combinations of the two, you need to send three requests: one with modes=pt_pub , one with modes=ps_tax , and one with modes=pt_pub&modes=ps_tax . The request with multiple modes will only return inter-modal results, no results for individual modes. A few things to note about this: This is done as inter-modal results can be slower to calculate due to the many combinations to crunch and them being likely to depend on external API calls, slowing things down further. By having the inter-modal request not returning single-modal results, you don't need to do any duplicate detection between the results of the different calls as they are mutually exclusive. You'll only get such inter-modal combinations where that combination is better in some way than using any individual mode by itself. It is therefore quite common that inter-modal requests result in an empty response.","title":"Single-modal vs. multi-modal routing"},{"location":"faq/#trips-groups-frequencies-and-templates","text":"What is the logic behind trip groups and what does the frequency property mean? Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times. Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group. In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest weightedScore . Why are segments split into references and templates? This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.","title":"Trips, groups, frequencies and templates"},{"location":"faq/#trips-results","text":"Why do I get trips with the first segment of a trip already in the past? When you have a trip group, you will get trips departing before the best one matching the query. What you should do is, grey it out in the UI and don't select it by default (the weighted score is a good indicator for this). Note that you can even get a trip group only with a trip in the past, e.g., if you queried for 12:15am and the last ferry left at 12:10. Why do I get trips having segments that \"go back in time\" and result in arriving after the depart of the next one? There may be cases where a segment of a trip is delayed, and due to realtime updates, the trip gets negative waiting times, e.g., a bus is delayed by 5 minutes and the trip had a connection of 2 minutes to take a train. These cases should be handled by the app, either by alerting the user, by recomputing the trip, or by any other measure you consider appropriate.","title":"Trips results"},{"location":"faq/#placeholders-in-segment-templates","text":"What are all the possible values for placeholders and how should they get interpreted? In order to use segment templates for multiple similar segments, the notes and action fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data. <NUMBER> : Placeholder for the number of short name of the transit service, e.g., segment.serviceNumber . <LINE_NAME> : Placeholder for the long name of the transit service, e.g., segment.serviceName . <DIRECTION> : Placeholder for the direction of the transit service, e.g., segment.serviceDirection . <LOCATIONS> : Placeholder for the start and end location of the segment, e.g., segment.start -> segment.end . <PLATFORM> : Placeholder for the embarkation platform of the transit service, e.g., segment.platform . <STOPS> : Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g., segment.stops . <TIME> *: Placeholder for the departure time of the segment, e.g., segment.startTime formatted as a time. Note that this can directly follow a <NUMBER> template, so you might have to add spacing. <DURATION> *: Placeholder for the total duration of the segment, e.g., segment.endTime - segment.startTime formatted as a duration string. <TRAFFIC> : (Badly named) placeholder for the total duration without traffic of the segment, e.g., segment.durationWithoutTraffic formatted as a duration string. * : Should be updated with real-time data.","title":"Placeholders in segment templates"},{"location":"faq/#advanced-routing-features","text":"How does wheelchair flag in true affect the resulting trips? There are three possible scenarios for public services, public stops, and paths: we know they are wheelchair accessible, we know they are not wheelchair accessible, or we don't have information about them. When the wheelchair flag is on, our routing engine will try to avoid services, stops and paths that are known by us to be inaccessible. In addition, we'll change 'walking' instructions to 'rolling' instructions, and indicate which sections are accessible, inaccessible or unknown. What's the action field in the alerts for? Sometimes we get real-time data that may change the accessibility status for public stops, for example when a lift is temporarily out of service in a train station. In these cases, we provide a mechanism that allows to identify the problem and send a re-route request specifically asking to avoid the stop(s) that have become inaccessible. If the embark/disembark stop of a public segment has issues, then we'll associate that segment with an alert describing the issue and containing a special action field of type rerouteExcludingStops which provides a list of the affected stop codes. Then if you want to get a new set of results avoiding those stops, you can add the avoidStops parameter to your original routing request, using the stop codes provided in the alert action field, and re-send it. Note that this new request will only avoid the stops you specifically indicated with the avoidStops parameter, so your new set of results may again include an alert for a different stop that also has issues. So you may want to send a third request asking to avoid this one too, but it's important that you include all of them in the avoidStops list, or otherwise you'll get again the stops that were first excluded.","title":"Advanced Routing Features"},{"location":"faq/#locations","text":"","title":"Locations"},{"location":"faq/#locations-cell-ids-and-hash-codes","text":"What are the cell IDs in the locations.json endpoint? The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as $(lat*cellsPerDegree)#$(lng*cellsPerDegree) . Got it. And cellIDHashCodes ? You typically call locations.json with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use cellIDHashCodes as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.","title":"Locations, cell IDs and hash codes"},{"location":"faq/#example","text":"Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request: { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDs\": [ \"-2540#11339\", \"-2540#11340\", \"-2540#11341\", \"-2541#11339\", \"-2541#11340\", \"-2541#11341\", \"-2542#11339\", \"-2542#11340\", \"-2542#11341\" ] } You'll then get results: { \"groups\": [ { \"hashCode\": 690784261, \"key\": \"-2540#11339\", \"stops\": [...] }, { \"hashCode\": -1940969928, \"key\": \"-2540#11340\", \"stops\": [...] } ] } You can then cache these and later on request again for changes by supplying cellIDHashCodes : { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDHashCodes\": { \"-2540#11339\": 690784261, \"-2540#11340\": -1940969928 } } Which will then only return any groups that have changed. If nothing changed, you'll just get back: { \"groups\": [] } Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself: { \"region\": \"AU_NSW_Sydney\", \"cellIDHashCodes\": { \"AU_NSW_Sydney\": 1096794422 } }","title":"Example"},{"location":"enterprise/bookings-api/","text":"Overview Note: Enterprise customers-only Note: Beta-only The TripGo API allows making bookings for a handful of transport service providers (TSPs). This enables your users to: Link their TSP accounts and keep credentials either stored on the client or server-side. Get a list of available TSP products for a trip. Book a specific TSP product for a single segment. Update the trip with the details of the booked TSP product. Update the trip with real-time data specific to that booking. Coming soon: Book a complete trip consisting of multiple products from multiple TSPs. In order to enable bookings for your TripGo API key, please get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials. API Endpoints Linking and unlinking accounts Before you can do any bookings, you will need to provide the relevant authentication details to the server. If the user has an account (as per the userToken header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet. auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a userToken is provided in the headers. If mode is provided, only information for that mode is returned. auth/{provider}/signin : Endpoint to link an account for the specified provider. auth/{provider}/logout : Endpoint to unlink an account for the specified provider. Auth Flow This flow will depend on the TSP and can be started in two separate ways: When linking accounts to a user. When doing a booking for that particular TSP and the user has no account already linked. This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow. For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including clientId , clientSecret , scope , authUrl , tokenUrl ; and also the required field to be POSTed, including accessToken , refreshToken and expiration . For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for Form-based Booking Flow . The end of this flow will depending on how it was started. If was started to link an account, the flow will end with an empty 204 response, when successfuly linked. If it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of Form-based Booking Flow . Getting available TSP for a trip If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment. The booking object in the segment may include: a quickBookingUrl , indicating that the quick booking flow is available. a bookingUrl , indicating that the form-based booking flow is available. Booking a segment To book a segment, either use the Form-based Booking Flow with the bookingURL either directly from the segment reference, or the Quick Booking Flow from the data returned after hitting quickBookingUrl . Form-based Booking Flow If form-based booking flow is available for a segment, the bookingUrl will return a Booking Form object with instructions to start the booking flow. A form-based booking flow will possible include the following steps: 1) return the available TSP products to allow the user choose one of them, 2) check whether we have user credentials to do the booking, if it does, skip 3, 3) start Auth flow , 4) attempt to do the booking and return the Status Form. Quick Booking Flow Getting available TSP products for a trip If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come: tripUpdateURL : A URL for fetching the trip, updated for this TSP product. bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of form-based booking flow ) title subtitle bookingTitle priceString price USDPrice surgeString surgeImageURL ETA imageURL Updating trip with booking details At the end of the booking flow, you will get a refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip. Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking. Trips with a confirmed booking will also have extra information about the confirmed booking in a field called confirmation in the booking field of the segment. This confirmation object may include detailed information about the provider , vehicle and status for the booking, with the following possible fields: a title a subtitle a valueUrl a value And also a list of possible actions depending on the status of the booking, with the following fields: a title a boolean isDestructive , indicating whether this action will cancel the booking. a internalUrl indicating the action of the url is a call to the same server and will return a bookingForm . a externalUrl indicating that the action must be handled by the app accordingly. Examples of actions with internalUrl fields are cancel booking , which will have the isDestructive field in true, and rate booking . Examples of actions with externalUrl fields are qrcode values, for showing a ticket to the user, and phone numbers, starting with tel: . Rating and Tipping Whenever available, the confirmation information will include the rate booking action, which will include an internalUrl which will return a bookingForm with the following fields: rate , an int value with min and max accepted values. feedback , a string to send an appropriate msg. tip , an int value indicating the amount to be paid as tip, in local currency. The booking form will include the action url to POST the data. Booking Form Specs Both the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps. There exists three different forms: Booking Form Auth Form Status Form All three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data. A Booking Form may include: a title a subtitle a value a BookingAction , which may include: a URL , to go to the next step in the flow a title a hudText , with a human readable string describing the action (meant to be shown while waiting the response from the backend) a boolean finalStep , meaning that the next step is the one that will actually do the booking. a boolean done , indicating that there are no more steps in the flow. a list of FormGroups . A FormGroup is a lisf of FormFields with a title and an optional footer. A FormField is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include: a (unique) id , to identify the field a title a subtitle a sidetitle a value , that will depend on the FormField type a boolean required , indicating that this is a required field to be POSTed, a boolean readOnly , indicating that this is information to be shown to the user but can not be edited. a boolean hidden , indicating that this field should NOT be shown to the user. There are several types of FormFields: string , which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER} text , for long non-editable strings switch , for boolean values option , for a list of values, will include the list and the default value address , for locations, value with the following format {lat, lng, address, name} datetime , including the time value in long and an extra field with the timezone id stepper , for int values, with extra max and min values time , for seconds since midnight password link , for urls, with an extra field called method with the following possible values: refresh meaning that this url will return the same step form, post meaning that the backend expects a POST on that url, external meaning that this will go to an external site, so, no BookingForm will be returned. bookingForm , this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request. For example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product. Bookings in the TripKit SDKs The TripKit SDKs implement support for bookings: Bookings in TripKit Android (coming soon) Bookings in TripKit iOS","title":"Bookings (API)"},{"location":"enterprise/bookings-api/#overview","text":"Note: Enterprise customers-only Note: Beta-only The TripGo API allows making bookings for a handful of transport service providers (TSPs). This enables your users to: Link their TSP accounts and keep credentials either stored on the client or server-side. Get a list of available TSP products for a trip. Book a specific TSP product for a single segment. Update the trip with the details of the booked TSP product. Update the trip with real-time data specific to that booking. Coming soon: Book a complete trip consisting of multiple products from multiple TSPs. In order to enable bookings for your TripGo API key, please get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials.","title":"Overview"},{"location":"enterprise/bookings-api/#api-endpoints","text":"","title":"API Endpoints"},{"location":"enterprise/bookings-api/#linking-and-unlinking-accounts","text":"Before you can do any bookings, you will need to provide the relevant authentication details to the server. If the user has an account (as per the userToken header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet. auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a userToken is provided in the headers. If mode is provided, only information for that mode is returned. auth/{provider}/signin : Endpoint to link an account for the specified provider. auth/{provider}/logout : Endpoint to unlink an account for the specified provider.","title":"Linking and unlinking accounts"},{"location":"enterprise/bookings-api/#auth-flow","text":"This flow will depend on the TSP and can be started in two separate ways: When linking accounts to a user. When doing a booking for that particular TSP and the user has no account already linked. This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow. For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including clientId , clientSecret , scope , authUrl , tokenUrl ; and also the required field to be POSTed, including accessToken , refreshToken and expiration . For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for Form-based Booking Flow . The end of this flow will depending on how it was started. If was started to link an account, the flow will end with an empty 204 response, when successfuly linked. If it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of Form-based Booking Flow .","title":"Auth Flow"},{"location":"enterprise/bookings-api/#getting-available-tsp-for-a-trip","text":"If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment. The booking object in the segment may include: a quickBookingUrl , indicating that the quick booking flow is available. a bookingUrl , indicating that the form-based booking flow is available.","title":"Getting available TSP for a trip"},{"location":"enterprise/bookings-api/#booking-a-segment","text":"To book a segment, either use the Form-based Booking Flow with the bookingURL either directly from the segment reference, or the Quick Booking Flow from the data returned after hitting quickBookingUrl .","title":"Booking a segment"},{"location":"enterprise/bookings-api/#form-based-booking-flow","text":"If form-based booking flow is available for a segment, the bookingUrl will return a Booking Form object with instructions to start the booking flow. A form-based booking flow will possible include the following steps: 1) return the available TSP products to allow the user choose one of them, 2) check whether we have user credentials to do the booking, if it does, skip 3, 3) start Auth flow , 4) attempt to do the booking and return the Status Form.","title":"Form-based Booking Flow"},{"location":"enterprise/bookings-api/#quick-booking-flow","text":"Getting available TSP products for a trip If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come: tripUpdateURL : A URL for fetching the trip, updated for this TSP product. bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of form-based booking flow ) title subtitle bookingTitle priceString price USDPrice surgeString surgeImageURL ETA imageURL","title":"Quick Booking Flow"},{"location":"enterprise/bookings-api/#updating-trip-with-booking-details","text":"At the end of the booking flow, you will get a refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip. Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking. Trips with a confirmed booking will also have extra information about the confirmed booking in a field called confirmation in the booking field of the segment. This confirmation object may include detailed information about the provider , vehicle and status for the booking, with the following possible fields: a title a subtitle a valueUrl a value And also a list of possible actions depending on the status of the booking, with the following fields: a title a boolean isDestructive , indicating whether this action will cancel the booking. a internalUrl indicating the action of the url is a call to the same server and will return a bookingForm . a externalUrl indicating that the action must be handled by the app accordingly. Examples of actions with internalUrl fields are cancel booking , which will have the isDestructive field in true, and rate booking . Examples of actions with externalUrl fields are qrcode values, for showing a ticket to the user, and phone numbers, starting with tel: .","title":"Updating trip with booking details"},{"location":"enterprise/bookings-api/#rating-and-tipping","text":"Whenever available, the confirmation information will include the rate booking action, which will include an internalUrl which will return a bookingForm with the following fields: rate , an int value with min and max accepted values. feedback , a string to send an appropriate msg. tip , an int value indicating the amount to be paid as tip, in local currency. The booking form will include the action url to POST the data.","title":"Rating and Tipping"},{"location":"enterprise/bookings-api/#booking-form-specs","text":"Both the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps. There exists three different forms: Booking Form Auth Form Status Form All three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data. A Booking Form may include: a title a subtitle a value a BookingAction , which may include: a URL , to go to the next step in the flow a title a hudText , with a human readable string describing the action (meant to be shown while waiting the response from the backend) a boolean finalStep , meaning that the next step is the one that will actually do the booking. a boolean done , indicating that there are no more steps in the flow. a list of FormGroups . A FormGroup is a lisf of FormFields with a title and an optional footer. A FormField is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include: a (unique) id , to identify the field a title a subtitle a sidetitle a value , that will depend on the FormField type a boolean required , indicating that this is a required field to be POSTed, a boolean readOnly , indicating that this is information to be shown to the user but can not be edited. a boolean hidden , indicating that this field should NOT be shown to the user. There are several types of FormFields: string , which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER} text , for long non-editable strings switch , for boolean values option , for a list of values, will include the list and the default value address , for locations, value with the following format {lat, lng, address, name} datetime , including the time value in long and an extra field with the timezone id stepper , for int values, with extra max and min values time , for seconds since midnight password link , for urls, with an extra field called method with the following possible values: refresh meaning that this url will return the same step form, post meaning that the backend expects a POST on that url, external meaning that this will go to an external site, so, no BookingForm will be returned. bookingForm , this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request. For example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.","title":"Booking Form Specs"},{"location":"enterprise/bookings-api/#bookings-in-the-tripkit-sdks","text":"The TripKit SDKs implement support for bookings: Bookings in TripKit Android (coming soon) Bookings in TripKit iOS","title":"Bookings in the TripKit SDKs"},{"location":"enterprise/bookings-ios/","text":"Bookings in TripKit iOS Note: Enterprise customers-only Note: Beta-only TripKit iOS supports all the booking API endpoints, including handling the OAuth process. OAuth credentials are stored securely in the device's keychain and, optionally, linked to the user's account. Preparations To get started, configured your project as follows: Include BookingKit from shared-ios , including all its dependencies. Include tripkit-ios as a dependency, including its Bookings add-on. Add the OAuthCallbackURL to your Config.plist configuration file. Make sure your app has the URL scheme from that callback URL registered. Next, you need to respond to calls to that OAuthCallbackURL in your application delegate by implementing application(openURL:options) (or its deprecated precursors), and handling the calls similar to this: let OAuthCallbackURL = SGKConfig.sharedIntance().oauthCallbackURL() if (URL.absoluteString.hasPrefix(OAuthCallbackURL.absoluteString)) { OAuthSwift.handleOpenURL(URL) return true } Linking and unlinking accounts You can then which accounts are available for linking for a given region: let region = SVKRegionManager.sharedInstance().regionWithName(...) region.linkedAccounts() { auths in for auth in auths { if auth.isConnected { // Update UI and allow unlinking } else { // Update UI and allow linking } } } This both checks which modes can be associated with an account, and also whether the credentials are already available. Credentials are available when they are either stored locally or associated with the user's account, and they have not expired. To kick of linking, which saves the credentials locally and to the user's account (if the user is logged in), there's a helper based on RxSwift : region.rx_linkAccount(mode, remoteURL: auth.actionURL) .subscribe { event in switch event { case .Next(let success): // Account has been linked. Update the UI. case .Error(let error): // Account could not get linked. Handle error. print(error) case .Completed: break // Nothing to do } } .addDisposableTo(disposeBag) Note that this helper requires the actionURL as this is used to fetch what information is necessary for the OAuth flow for the provider servicing the specified mode : These credentials will then be used automatically later on when bookings are made. To check, whether credentials are currently stored and still valid (they can expire), you can use the region.linkedAccounts() helper above. For unlinking an account again there's another helper: region.unlinkAccount(mode, remoteURL: auth.actionURL) { success in // Do something } Note that the helper for unlinking, only requires the actionURL when the OAuth credentials have been associated with the user's account. Unlinking removes credentials stored locally and those associated with the user's account. Getting available TSP products for a trip Available TSP products for a trip are associated with a segment. The information about these products is not included in the standard routing responses, but needs to be fetched separately. Whether such TSP products are available, is indicated by the segment having a bookingQuickInternalURL . If that URL exists, the TKQuickBookingHelper can then fetch all the available products: TKQuickBookingHelper.fetchQuickBookings(forSegment: segment) { quickBookings in // Update UI } Note : Fetching this information does typically not require the user to have linked their account with the TSP of that segment. Each of these come with a variety of information about the product, possibly including information on the price or ETA. The two main actions that you can take with these details are: Update the trip with the product, using the tripUpdateURL (see below for details). This is useful if you need the trip's properties to reflect the price and ETA of the selected product. Book the product, the using bookingURL (see below for details). Booking a segment Users can book trip on a segment-by-segment basis. The booking requires the bookingURL for the specific product that the user wants to book as mentioned in the previous section. TripKit iOS has a helper method BPKOperator.makeBookingToURL/2 which then initiates the booking: let mode = segment.modeIdentifier() BPKOperator.makeBookingToURL(mode, URL: bookingURL) .subscribe { event in switch event { case .Next(.UpdateTrip(let url)): // Booking went through. Update the trip (see below). case .Next(.LoadForm(let form)): // More information required. // Display booking form using `BPKBookingViewController` case .Next(.ShowAgreement(let displayUrl, let discardUrl)) // User confirmation required. case .Error(let error): // Handle error case .Completed: break // Nothing to do } } .addDisposableTo(disposeBag) } This method does a handful of things: It checks whether the user has already linked their account for the provider of the segment (the credentials are linked to the segment's mode, which is why the method takes the mode parameter). If the user's account has not been linked, the BPKOperator will start the OAuth process described in the section on linking accounts . If the user's account has already been linked, those credentials will be used. If there's an error during this process, then observable aborts with an error. An attempt to make the booking is performed, which can have the following outcomes: The booking was successful and BookingResult.UpdateTrip is returned with a URL to update the trip, which will then include the confirmation details. The booking can be made, but more information is required by the user. This is the case BookingResult.LoadTrip which returns a booking form, which can be then be displayed using the BPKBookingViewController . The booking can be made, but the user first need to accept an agreement. This is the case `BookingResult.UpdateTrip which returns two URLs. The first URL should be displayed to the user, and the user has accepted the terms once the user gets to the second URL. If the user accepted, you should then kick off the initial call to BPKOperator.makeBookingToURL again. If there's an error, the observable aborts with an error. Updating trip with booking details / confirmation As described above, the booking process provides URLs to fetch an update of the trip. This can be used to update a trip with a selected TSP process, and also to fetch the booking status of a trip. This process is the same as updating a trip with real-time data, e.g.: let router = TKBuzzRouter() let context = TKTripKit.sharedInstance().tripKitContext router.downloadTrip(url, intoTripKitContext: context) { updatedTrip in if let updatedTrip = updatedTrip { let request = originalTrip.request originalTrip.removeFromRequest() updatedTrip.moveToRequest(request, markAsPreferred: true) } } Noteworthy is here, the segment.bookingConfirmation property provided by TKQuickBookingHelper which returns a TKBookingConfirmation struct after a booking has been made. This struct includes: status : A title and optional description describing the current status of the trip. Information on the provider and vehicle servicing this booking. Note that these can be missing; typically while the booking is still being processed by the TSP, in the cast that it has been cancelled, or also after the trip has been completed. A list of actions, such as calling the provider or cancelling the booking.","title":"Bookings (iOS)"},{"location":"enterprise/bookings-ios/#bookings-in-tripkit-ios","text":"Note: Enterprise customers-only Note: Beta-only TripKit iOS supports all the booking API endpoints, including handling the OAuth process. OAuth credentials are stored securely in the device's keychain and, optionally, linked to the user's account.","title":"Bookings in TripKit iOS"},{"location":"enterprise/bookings-ios/#preparations","text":"To get started, configured your project as follows: Include BookingKit from shared-ios , including all its dependencies. Include tripkit-ios as a dependency, including its Bookings add-on. Add the OAuthCallbackURL to your Config.plist configuration file. Make sure your app has the URL scheme from that callback URL registered. Next, you need to respond to calls to that OAuthCallbackURL in your application delegate by implementing application(openURL:options) (or its deprecated precursors), and handling the calls similar to this: let OAuthCallbackURL = SGKConfig.sharedIntance().oauthCallbackURL() if (URL.absoluteString.hasPrefix(OAuthCallbackURL.absoluteString)) { OAuthSwift.handleOpenURL(URL) return true }","title":"Preparations"},{"location":"enterprise/bookings-ios/#linking-and-unlinking-accounts","text":"You can then which accounts are available for linking for a given region: let region = SVKRegionManager.sharedInstance().regionWithName(...) region.linkedAccounts() { auths in for auth in auths { if auth.isConnected { // Update UI and allow unlinking } else { // Update UI and allow linking } } } This both checks which modes can be associated with an account, and also whether the credentials are already available. Credentials are available when they are either stored locally or associated with the user's account, and they have not expired. To kick of linking, which saves the credentials locally and to the user's account (if the user is logged in), there's a helper based on RxSwift : region.rx_linkAccount(mode, remoteURL: auth.actionURL) .subscribe { event in switch event { case .Next(let success): // Account has been linked. Update the UI. case .Error(let error): // Account could not get linked. Handle error. print(error) case .Completed: break // Nothing to do } } .addDisposableTo(disposeBag) Note that this helper requires the actionURL as this is used to fetch what information is necessary for the OAuth flow for the provider servicing the specified mode : These credentials will then be used automatically later on when bookings are made. To check, whether credentials are currently stored and still valid (they can expire), you can use the region.linkedAccounts() helper above. For unlinking an account again there's another helper: region.unlinkAccount(mode, remoteURL: auth.actionURL) { success in // Do something } Note that the helper for unlinking, only requires the actionURL when the OAuth credentials have been associated with the user's account. Unlinking removes credentials stored locally and those associated with the user's account.","title":"Linking and unlinking accounts"},{"location":"enterprise/bookings-ios/#getting-available-tsp-products-for-a-trip","text":"Available TSP products for a trip are associated with a segment. The information about these products is not included in the standard routing responses, but needs to be fetched separately. Whether such TSP products are available, is indicated by the segment having a bookingQuickInternalURL . If that URL exists, the TKQuickBookingHelper can then fetch all the available products: TKQuickBookingHelper.fetchQuickBookings(forSegment: segment) { quickBookings in // Update UI } Note : Fetching this information does typically not require the user to have linked their account with the TSP of that segment. Each of these come with a variety of information about the product, possibly including information on the price or ETA. The two main actions that you can take with these details are: Update the trip with the product, using the tripUpdateURL (see below for details). This is useful if you need the trip's properties to reflect the price and ETA of the selected product. Book the product, the using bookingURL (see below for details).","title":"Getting available TSP products for a trip"},{"location":"enterprise/bookings-ios/#booking-a-segment","text":"Users can book trip on a segment-by-segment basis. The booking requires the bookingURL for the specific product that the user wants to book as mentioned in the previous section. TripKit iOS has a helper method BPKOperator.makeBookingToURL/2 which then initiates the booking: let mode = segment.modeIdentifier() BPKOperator.makeBookingToURL(mode, URL: bookingURL) .subscribe { event in switch event { case .Next(.UpdateTrip(let url)): // Booking went through. Update the trip (see below). case .Next(.LoadForm(let form)): // More information required. // Display booking form using `BPKBookingViewController` case .Next(.ShowAgreement(let displayUrl, let discardUrl)) // User confirmation required. case .Error(let error): // Handle error case .Completed: break // Nothing to do } } .addDisposableTo(disposeBag) } This method does a handful of things: It checks whether the user has already linked their account for the provider of the segment (the credentials are linked to the segment's mode, which is why the method takes the mode parameter). If the user's account has not been linked, the BPKOperator will start the OAuth process described in the section on linking accounts . If the user's account has already been linked, those credentials will be used. If there's an error during this process, then observable aborts with an error. An attempt to make the booking is performed, which can have the following outcomes: The booking was successful and BookingResult.UpdateTrip is returned with a URL to update the trip, which will then include the confirmation details. The booking can be made, but more information is required by the user. This is the case BookingResult.LoadTrip which returns a booking form, which can be then be displayed using the BPKBookingViewController . The booking can be made, but the user first need to accept an agreement. This is the case `BookingResult.UpdateTrip which returns two URLs. The first URL should be displayed to the user, and the user has accepted the terms once the user gets to the second URL. If the user accepted, you should then kick off the initial call to BPKOperator.makeBookingToURL again. If there's an error, the observable aborts with an error.","title":"Booking a segment"},{"location":"enterprise/bookings-ios/#updating-trip-with-booking-details-confirmation","text":"As described above, the booking process provides URLs to fetch an update of the trip. This can be used to update a trip with a selected TSP process, and also to fetch the booking status of a trip. This process is the same as updating a trip with real-time data, e.g.: let router = TKBuzzRouter() let context = TKTripKit.sharedInstance().tripKitContext router.downloadTrip(url, intoTripKitContext: context) { updatedTrip in if let updatedTrip = updatedTrip { let request = originalTrip.request originalTrip.removeFromRequest() updatedTrip.moveToRequest(request, markAsPreferred: true) } } Noteworthy is here, the segment.bookingConfirmation property provided by TKQuickBookingHelper which returns a TKBookingConfirmation struct after a booking has been made. This struct includes: status : A title and optional description describing the current status of the trip. Information on the provider and vehicle servicing this booking. Note that these can be missing; typically while the booking is still being processed by the TSP, in the cast that it has been cancelled, or also after the trip has been completed. A list of actions, such as calling the provider or cancelling the booking.","title":"Updating trip with booking details / confirmation"},{"location":"enterprise/push/","text":"Push Notifications Note: Enterprise customers-only Note: Beta-only We support Push Notifications for both Android (using Firebase ) and iOS (using APN ) devices. In order to enable and use Push Notifications, the following steps are required: Register (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details). Each app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using data/user/push endpoint. To send PN to your user, you need to know the user ID on our database and use data/push endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted). Android You need to create your own project in Firebase and send to us the Server Key in your project settings > cloud messaging tab. For instructions on how to implement Push Notifications in Android, go to Firebase Cloud Messaging . In short, your app needs to register into FCM to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. iOS You need to configure your app for APN, follow instructions from Apple or use fastlane , and then send us both the P12 file, containing the Apple Push Notification Authentication Key , and the password to unlock it. For instructions on how to implement Push Notifications in iOS, go to Configuring Remote Notification . In short, your app needs to register into APN to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. The token returned by the iOS SDK will be a binary data object, while our backend expends a string. To turn the data into a string, use this snipped: let tokenString = tokenData.reduce(into: \"\") { $0.append(String(format: \"%02X\", $1)) } When receiving push notifications, additional fields that were provide in the data part when sending the notification, will be accessible to your app via the userInfo that's attached to the content of the notification. The clickAction will end up in the notification's content's categoryIdentifier . Sending PN If you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use data/push endpoint to send notifications to a list of users (by their userID). Notifications that we send support a title, message, sound and badge, with a ttl (time to live) value, as well as custom data which will be passed on to your apps. Be mindful of size limits imposed by Firebase or APN.","title":"Push Notifications"},{"location":"enterprise/push/#push-notifications","text":"Note: Enterprise customers-only Note: Beta-only We support Push Notifications for both Android (using Firebase ) and iOS (using APN ) devices. In order to enable and use Push Notifications, the following steps are required: Register (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details). Each app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using data/user/push endpoint. To send PN to your user, you need to know the user ID on our database and use data/push endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted).","title":"Push Notifications"},{"location":"enterprise/push/#android","text":"You need to create your own project in Firebase and send to us the Server Key in your project settings > cloud messaging tab. For instructions on how to implement Push Notifications in Android, go to Firebase Cloud Messaging . In short, your app needs to register into FCM to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database.","title":"Android"},{"location":"enterprise/push/#ios","text":"You need to configure your app for APN, follow instructions from Apple or use fastlane , and then send us both the P12 file, containing the Apple Push Notification Authentication Key , and the password to unlock it. For instructions on how to implement Push Notifications in iOS, go to Configuring Remote Notification . In short, your app needs to register into APN to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. The token returned by the iOS SDK will be a binary data object, while our backend expends a string. To turn the data into a string, use this snipped: let tokenString = tokenData.reduce(into: \"\") { $0.append(String(format: \"%02X\", $1)) } When receiving push notifications, additional fields that were provide in the data part when sending the notification, will be accessible to your app via the userInfo that's attached to the content of the notification. The clickAction will end up in the notification's content's categoryIdentifier .","title":"iOS"},{"location":"enterprise/push/#sending-pn","text":"If you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use data/push endpoint to send notifications to a list of users (by their userID). Notifications that we send support a title, message, sound and badge, with a ttl (time to live) value, as well as custom data which will be passed on to your apps. Be mindful of size limits imposed by Firebase or APN.","title":"Sending PN"},{"location":"enterprise/tripurls/","text":"Trips URLs Whenever a trip is computed, it will be returned with a list of URLs, including: temporaryURL : Temporary URL used to retried the trip, which can be used for short-term sharing. saveURL : Temporary URL used to make the trip persistent. updateURL : Optional temporary URL used to update the trip with real-time data. hookURL (beta): Optional temporary URL used to hook the trip with real-time updates. progressURL : Optional temporary URL used to report progress updates for the trip. plannedURL : Optional temporary URL used for analytics. logURL (beta): Optional temporary URL used to log the trip in the user account. shareURL : Optional persistent of this trip URL, which can be used for sharing trips (web access only) appURL : Optional persistent of this trip URL, which can be used retrieving them long term (json access only). Trip access The temporaryURL allows access to the trip for a short-term period (maximum of 7 days from the time of creation), while our platform keeps the trip in the server that computed it originally. If you want a trip to persist forever, you can use the saveURL to save it in permanent storage (requires AWS DynamoDB connection). Saving the trip will create a new unique ID, along with two new urls: shareURL for web access and appURL for app/json access. Analytics The plannedURL is meant to be used for analytics purposes, to keep track, from the returned trips, which of them the user actually took, if that is possible to determine or guess at a client/app level. The progressURL goals is to enable apps to report user progress on a specific trip, also for analytics purposes. Save trip It's available for all trips. saveURL makes sure that a trip will be accessible at a later time, beyond what would be a typical user session. Otherwise our API makes no guarantee that a trip calculated is still available later. It is important to mention that the trip saved could change when reconstructing it from our database if there's newer real-time data available. Real-time updates Its optional as not all trips would ever get real-time data updates. If our platforms has real-time information that can be used to update a computed trip, both updateURL and hookURL will be present in the response. Both support the same goal of updating the trip with real-time information, one by pulling and the other by pushing. updateURL Allows providing a hash code so that it'll only return trip details if anything about the trip has changed since you last fetched it. This is so that apps can frequently hit that endpoint and only need to parse the response if there's any changes to the trip. See documentation Pulling for changes The updateURL can be used to pull our servers for changes in the trip. This url is meant to be used by the apps to get an updated version of the trip. This endpoint will return an empty response if there is no change, otherwise, it will return the trip in the requested format. As an example, if a service is delayed, the trip will be updated to reflect that change. Also, if the trip involves a booking to a TSP, like Uber for example, it will be getting updates of the status of the ride, as soon as those are available from the external API. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the updateURL is returned. The client checks whether the trip has been updated with real-time changes by doing a GET to the updateURL . If the trip has been updated, the new updateURL should be used from now on. After two hours of not getting any update, the trip is discarded from memory. For more details, check our docs Receiving notifications The hookURL can be used to register a callback or web-hook, and our platform will then inform if any change in that trip occurs by POSTing to the registered url the tripID along with the tripURL for the client to retrieve the updated trip. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the hookURL is returned. The client that wants to receive notifications about real-time changes does a POST to the hookURL ( docs ) send the webhook as url and any required header (starting with x- ) as body of the request and obtains a 204 response. At any given time the trip is updated with any real-time change, our platform does a POST to the registered web-hook. After two hours of not getting any update, the trip is discarded from memory and won't receive any more updates. The client can also remove a web-hook, by doing a DELETE request to hookURL ( docs ), and can also get the status of the hook (to confirm whether there is a hook already registered), by doing a GET to hookURL ( docs ). Note that only one web-hook per trip can be registered, and multiple calls to hookURL to register different web-hooks will override existing ones.","title":"Trip URLs"},{"location":"enterprise/tripurls/#trips-urls","text":"Whenever a trip is computed, it will be returned with a list of URLs, including: temporaryURL : Temporary URL used to retried the trip, which can be used for short-term sharing. saveURL : Temporary URL used to make the trip persistent. updateURL : Optional temporary URL used to update the trip with real-time data. hookURL (beta): Optional temporary URL used to hook the trip with real-time updates. progressURL : Optional temporary URL used to report progress updates for the trip. plannedURL : Optional temporary URL used for analytics. logURL (beta): Optional temporary URL used to log the trip in the user account. shareURL : Optional persistent of this trip URL, which can be used for sharing trips (web access only) appURL : Optional persistent of this trip URL, which can be used retrieving them long term (json access only).","title":"Trips URLs"},{"location":"enterprise/tripurls/#trip-access","text":"The temporaryURL allows access to the trip for a short-term period (maximum of 7 days from the time of creation), while our platform keeps the trip in the server that computed it originally. If you want a trip to persist forever, you can use the saveURL to save it in permanent storage (requires AWS DynamoDB connection). Saving the trip will create a new unique ID, along with two new urls: shareURL for web access and appURL for app/json access.","title":"Trip access"},{"location":"enterprise/tripurls/#analytics","text":"The plannedURL is meant to be used for analytics purposes, to keep track, from the returned trips, which of them the user actually took, if that is possible to determine or guess at a client/app level. The progressURL goals is to enable apps to report user progress on a specific trip, also for analytics purposes.","title":"Analytics"},{"location":"enterprise/tripurls/#save-trip","text":"It's available for all trips. saveURL makes sure that a trip will be accessible at a later time, beyond what would be a typical user session. Otherwise our API makes no guarantee that a trip calculated is still available later. It is important to mention that the trip saved could change when reconstructing it from our database if there's newer real-time data available.","title":"Save trip"},{"location":"enterprise/tripurls/#real-time-updates","text":"Its optional as not all trips would ever get real-time data updates. If our platforms has real-time information that can be used to update a computed trip, both updateURL and hookURL will be present in the response. Both support the same goal of updating the trip with real-time information, one by pulling and the other by pushing. updateURL Allows providing a hash code so that it'll only return trip details if anything about the trip has changed since you last fetched it. This is so that apps can frequently hit that endpoint and only need to parse the response if there's any changes to the trip. See documentation","title":"Real-time updates"},{"location":"enterprise/tripurls/#pulling-for-changes","text":"The updateURL can be used to pull our servers for changes in the trip. This url is meant to be used by the apps to get an updated version of the trip. This endpoint will return an empty response if there is no change, otherwise, it will return the trip in the requested format. As an example, if a service is delayed, the trip will be updated to reflect that change. Also, if the trip involves a booking to a TSP, like Uber for example, it will be getting updates of the status of the ride, as soon as those are available from the external API. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the updateURL is returned. The client checks whether the trip has been updated with real-time changes by doing a GET to the updateURL . If the trip has been updated, the new updateURL should be used from now on. After two hours of not getting any update, the trip is discarded from memory. For more details, check our docs","title":"Pulling for changes"},{"location":"enterprise/tripurls/#receiving-notifications","text":"The hookURL can be used to register a callback or web-hook, and our platform will then inform if any change in that trip occurs by POSTing to the registered url the tripID along with the tripURL for the client to retrieve the updated trip. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the hookURL is returned. The client that wants to receive notifications about real-time changes does a POST to the hookURL ( docs ) send the webhook as url and any required header (starting with x- ) as body of the request and obtains a 204 response. At any given time the trip is updated with any real-time change, our platform does a POST to the registered web-hook. After two hours of not getting any update, the trip is discarded from memory and won't receive any more updates. The client can also remove a web-hook, by doing a DELETE request to hookURL ( docs ), and can also get the status of the hook (to confirm whether there is a hook already registered), by doing a GET to hookURL ( docs ). Note that only one web-hook per trip can be registered, and multiple calls to hookURL to register different web-hooks will override existing ones.","title":"Receiving notifications"},{"location":"guides/deep-links/","text":"Deep Linking For a light-weight alternative to using our API, you can also deep-link into the TripGo app. Routing results $schema://$host/go?$parameters Opens the routing results for the specified destination, and optionally the start and time: flat , flng : Start coordinates. If not specified, the user's current location is used. tlat , tlng : End coordinates. Required, unless tname is provided. tname : Destination as a search string (supports what3words ). Required, unless tlat and tlng are provided. type : 0 for leaving ASAP, 1 for leaving after time , 2 for arriving by time . Required. time : Query time in seconds since 1970. Required, unless type is set to 0 . Examples: iOS: tripgo:///go?tname=dragon.letter.spoke Web: http://tripgo.com/go?tname=dragon.letter.spoke Destination information $schema://$host/meet?$parameters Opens the search screen with the destination and arrival time filled in. lat , lng : Coordinate where to meet. Required, unless name is provided. name : Destination as a search string (supports what3words ). Required, unless lat and lng are provided. time : Arrival time in seconds since 1970. Required. Examples: iOS: tripgo:///meet?lat=-33.94501&lng=151.25807&at=1385535734 Web: http://tripgo.com/meet?lat=-33.94501&lng=151.25807&at=1385535734 Timetable $schema://$host/stop/$region/$stopCode Opens the departures timetable for a given stop. $region and $stop use region codes and stop codes as defined in our API. Examples: iOS: tripgo:///stop/AU_NSW_Sydney/2035143 Web: http://tripgo.com/stop/AU_NSW_Sydney/2035143","title":"Deep Linking"},{"location":"guides/deep-links/#deep-linking","text":"For a light-weight alternative to using our API, you can also deep-link into the TripGo app.","title":"Deep Linking"},{"location":"guides/deep-links/#routing-results","text":"$schema://$host/go?$parameters Opens the routing results for the specified destination, and optionally the start and time: flat , flng : Start coordinates. If not specified, the user's current location is used. tlat , tlng : End coordinates. Required, unless tname is provided. tname : Destination as a search string (supports what3words ). Required, unless tlat and tlng are provided. type : 0 for leaving ASAP, 1 for leaving after time , 2 for arriving by time . Required. time : Query time in seconds since 1970. Required, unless type is set to 0 . Examples: iOS: tripgo:///go?tname=dragon.letter.spoke Web: http://tripgo.com/go?tname=dragon.letter.spoke","title":"Routing results"},{"location":"guides/deep-links/#destination-information","text":"$schema://$host/meet?$parameters Opens the search screen with the destination and arrival time filled in. lat , lng : Coordinate where to meet. Required, unless name is provided. name : Destination as a search string (supports what3words ). Required, unless lat and lng are provided. time : Arrival time in seconds since 1970. Required. Examples: iOS: tripgo:///meet?lat=-33.94501&lng=151.25807&at=1385535734 Web: http://tripgo.com/meet?lat=-33.94501&lng=151.25807&at=1385535734","title":"Destination information"},{"location":"guides/deep-links/#timetable","text":"$schema://$host/stop/$region/$stopCode Opens the departures timetable for a given stop. $region and $stop use region codes and stop codes as defined in our API. Examples: iOS: tripgo:///stop/AU_NSW_Sydney/2035143 Web: http://tripgo.com/stop/AU_NSW_Sydney/2035143","title":"Timetable"},{"location":"guides/sdks/","text":"","title":"Sdks"},{"location":"bower_components/normalize-scss/CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include, but are not limited to: using an official project e-mail address posting via an official social media account, acting as an appointed representative at an online or offline event, or declaring your involvement in the project at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at virtually.johnalbin@gmail.com; please include \"conduct\" in the title of the email. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Contributor Covenant Code of Conduct"},{"location":"bower_components/normalize-scss/CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"bower_components/normalize-scss/CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"bower_components/normalize-scss/CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"bower_components/normalize-scss/CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"bower_components/normalize-scss/CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include, but are not limited to: using an official project e-mail address posting via an official social media account, acting as an appointed representative at an online or offline event, or declaring your involvement in the project at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"bower_components/normalize-scss/CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at virtually.johnalbin@gmail.com; please include \"conduct\" in the title of the email. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"bower_components/normalize-scss/CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"bower_components/normalize-scss/LICENSE/","text":"Copyright \u00a9 Nicolas Gallagher and Jonathan Neal and John Albin Wilkins Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"bower_components/normalize-scss/","text":"normalize-scss Latest versions For use with\u2026 normalize-scss version Sass 3.4 or libSass 7.0.0 combining normalize.css v7.0.0 with v1.1.3 Ruby Sass 3.3 3.0.3 combining normalize.css v3.0.3 with v1.1.3 Ruby Sass 3.2 2.2.0+normalize.2.1.3 combining normalize.css v2.1.3 with v1.1.3 The Sass port of normalize.css This project is the Sass version of Normalize.css , a collection of HTML element and attribute rulesets to normalize styles across all browsers. This port aims to use a light dusting of Sass to make Normalize even easier to integrate with your website. To learn about why Normalize.css is so amazing, skip to the \"normalize.css\" section below. This Sass port currently adds: Vertical rhythm mixins: Allowing you to alter the font-size, line-height and margins in Normalize\u2019s output without hacking the library. Optional Eyeglass support. Several ready-to-fork versions that integrate typography Sass modules like Typey, style guides built with KSS, or the legacy Compass module. normalize.css v5 A modern alternative to CSS resets Normalize.css is a customisable CSS file that makes browsers render all elements more consistently and in line with modern standards. The project relies on researching the differences between default browser styles in order to precisely target only the styles that need or benefit from normalizing. View the test file What does it do? Preserves useful defaults, unlike many CSS resets. Normalizes styles for a wide range of elements. Corrects bugs and common browser inconsistencies. Improves usability with subtle modifications. Explains what code does using detailed comments. Install Install using one of the following methods: Download directly from the project page . Install with npm : npm install --save normalize-scss Install with Bower : bower install --save normalize.scss Install with Ruby Gem : gem install normalize-scss and, if using Compass, add require \"normalize-scss\" to your config.rb file. Note: if you want to alter the _normalize.scss file after installation (see \"how to use it\" below), you can use the gem list --details normalize-scss command to show you where the normalize-scss files were installed. How to use it There is a fantastic introduction to the project and brief instructions how to use it in the About normalize.css article . You can use the Sass port of Normalize in one of several methods, following the \"About normalize.css\" article's suggestions: Approach 1: Download and use normalize-scss as a starting point for your own project's base Sass, customising the values to match the design's requirements. (The best approach, IMO .) 1. Copy the normalize-scss files to your sass directory so that you can alter it as you include it in your project. To aid with this method, normalize-scss includes several ready-made \"fork\" versions: * fork-versions/default - Fork for libSass or Ruby Sass * fork-versions/deprecated-compass - Fork with Compass ( deprecated ) * fork-versions/typey - Fork with Typey * fork-versions/typey-chroma-kss - Fork with Typey, Chroma and KSS Approach 2: Install and include normalize-scss untouched and then build upon it, overriding the defaults later in your Sass when necessary. Just import normalize-scss like any normal Sass module by: 1. Set variables to override the default normalize-scss variables. 2. (Optionally) add an additional [path to]/normalize-scss/sass import path for your Sass compiler, e.g. node-sass' includePaths option or Ruby Sass' --load-path option. 3. Import with @import \"normalize\"; or with @import \"[path to]/normalize-scss/sass/normalize\"; (if you skipped step 2.) 4. Output the CSS rules with @include normalize(); Alternatively, you can import normalize-scss immediately into your main Sass file without needing to use the normalize() mixin by: (Optionally) set variables to override the default normalize-scss variables. (Optionally) add an additional [path to]/normalize-scss/sass import path for your Sass compiler, e.g. node-sass' includePaths option or Ruby Sass' --load-path option. Import with @import \"normalize/import-now\"; or with @import \"[path to]/normalize-scss/sass/normalize/import-now\"; (if you skipped step 2.) Note: if you use wiredep , normalize-scss's bower.json points at the normalize/import-now Sass partial. If you don't wish to immediately output the CSS, you will need to override the Sass partial that wiredep grabs from normalize-scss. Browser support Chrome (last four) Edge (version 25 and later) Firefox (last four) Firefox ESR Internet Explorer 9+ Opera (last four) Safari (last four) Extended details and known issues Additional detail and explanation of the esoteric parts of normalize.css. pre, code, kbd, samp The font-family: monospace, monospace hack fixes the inheritance and scaling of font-size for preformatted text. The duplication of monospace is intentional. Source . sub, sup Normally, using sub or sup affects the line-box height of text in all browsers. Source . svg:not(:root) Adding overflow: hidden fixes IE9's SVG rendering. Earlier versions of IE don't support SVG, so we can safely use the :not() and :root selectors that modern browsers use in the default UA stylesheets to apply this style. Source . select By default, Chrome on OS X and Safari on OS X allow very limited styling of select , unless a border property is set. The default font weight on optgroup elements cannot safely be changed in Chrome on OSX and Safari on OS X. [type=\"checkbox\"] It is recommended that you do not style checkbox and radio inputs as Firefox's implementation does not respect box-sizing, padding, or width. [type=\"number\"] Certain font size values applied to number inputs cause the cursor style of the decrement button to change from default to text . [type=\"search\"] The search input is not fully stylable by default. In Chrome and Safari on OSX/iOS you can't control font , padding , border , or background . In Chrome and Safari on Windows you can't control border properly. It will apply border-width but will only show a border color (which cannot be controlled) for the outer 1px of that border. Applying -webkit-appearance: textfield addresses these issues without removing the benefits of search inputs (e.g. showing past searches). Safari (but not Chrome) will clip the cancel button on when it has padding (and textfield appearance). Contributing Please read Normalize.css' contributing guidelines . Updates to most CSS rules should be reported to the upstream Normalize.css project . Updates to the Sass should be reported in the Normalize-scss project . Acknowledgements Normalize.css is a project by Nicolas Gallagher , co-created with Jonathan Neal . This Sass port is a project by John Albin Wilkins . Other ports of Normalize.css For the record, there are several other Sass ports as well. Including: https://github.com/waynegraham/compass-normalize-plugin https://github.com/ksmandersen/compass-normalize https://github.com/hail2u/normalize.scss https://github.com/kristerkari/normalize.scss https://github.com/krisbulman/normalize-libsass","title":"normalize-scss"},{"location":"bower_components/normalize-scss/#normalize-scss","text":"","title":"normalize-scss"},{"location":"bower_components/normalize-scss/#latest-versions","text":"For use with\u2026 normalize-scss version Sass 3.4 or libSass 7.0.0 combining normalize.css v7.0.0 with v1.1.3 Ruby Sass 3.3 3.0.3 combining normalize.css v3.0.3 with v1.1.3 Ruby Sass 3.2 2.2.0+normalize.2.1.3 combining normalize.css v2.1.3 with v1.1.3","title":"Latest versions"},{"location":"bower_components/normalize-scss/#the-sass-port-of-normalizecss","text":"This project is the Sass version of Normalize.css , a collection of HTML element and attribute rulesets to normalize styles across all browsers. This port aims to use a light dusting of Sass to make Normalize even easier to integrate with your website. To learn about why Normalize.css is so amazing, skip to the \"normalize.css\" section below. This Sass port currently adds: Vertical rhythm mixins: Allowing you to alter the font-size, line-height and margins in Normalize\u2019s output without hacking the library. Optional Eyeglass support. Several ready-to-fork versions that integrate typography Sass modules like Typey, style guides built with KSS, or the legacy Compass module.","title":"The Sass port of normalize.css"},{"location":"bower_components/normalize-scss/#normalizecss-v5","text":"A modern alternative to CSS resets Normalize.css is a customisable CSS file that makes browsers render all elements more consistently and in line with modern standards. The project relies on researching the differences between default browser styles in order to precisely target only the styles that need or benefit from normalizing. View the test file","title":"normalize.css v5"},{"location":"bower_components/normalize-scss/#what-does-it-do","text":"Preserves useful defaults, unlike many CSS resets. Normalizes styles for a wide range of elements. Corrects bugs and common browser inconsistencies. Improves usability with subtle modifications. Explains what code does using detailed comments.","title":"What does it do?"},{"location":"bower_components/normalize-scss/#install","text":"Install using one of the following methods: Download directly from the project page . Install with npm : npm install --save normalize-scss Install with Bower : bower install --save normalize.scss Install with Ruby Gem : gem install normalize-scss and, if using Compass, add require \"normalize-scss\" to your config.rb file. Note: if you want to alter the _normalize.scss file after installation (see \"how to use it\" below), you can use the gem list --details normalize-scss command to show you where the normalize-scss files were installed.","title":"Install"},{"location":"bower_components/normalize-scss/#how-to-use-it","text":"There is a fantastic introduction to the project and brief instructions how to use it in the About normalize.css article . You can use the Sass port of Normalize in one of several methods, following the \"About normalize.css\" article's suggestions: Approach 1: Download and use normalize-scss as a starting point for your own project's base Sass, customising the values to match the design's requirements. (The best approach, IMO .) 1. Copy the normalize-scss files to your sass directory so that you can alter it as you include it in your project. To aid with this method, normalize-scss includes several ready-made \"fork\" versions: * fork-versions/default - Fork for libSass or Ruby Sass * fork-versions/deprecated-compass - Fork with Compass ( deprecated ) * fork-versions/typey - Fork with Typey * fork-versions/typey-chroma-kss - Fork with Typey, Chroma and KSS Approach 2: Install and include normalize-scss untouched and then build upon it, overriding the defaults later in your Sass when necessary. Just import normalize-scss like any normal Sass module by: 1. Set variables to override the default normalize-scss variables. 2. (Optionally) add an additional [path to]/normalize-scss/sass import path for your Sass compiler, e.g. node-sass' includePaths option or Ruby Sass' --load-path option. 3. Import with @import \"normalize\"; or with @import \"[path to]/normalize-scss/sass/normalize\"; (if you skipped step 2.) 4. Output the CSS rules with @include normalize(); Alternatively, you can import normalize-scss immediately into your main Sass file without needing to use the normalize() mixin by: (Optionally) set variables to override the default normalize-scss variables. (Optionally) add an additional [path to]/normalize-scss/sass import path for your Sass compiler, e.g. node-sass' includePaths option or Ruby Sass' --load-path option. Import with @import \"normalize/import-now\"; or with @import \"[path to]/normalize-scss/sass/normalize/import-now\"; (if you skipped step 2.) Note: if you use wiredep , normalize-scss's bower.json points at the normalize/import-now Sass partial. If you don't wish to immediately output the CSS, you will need to override the Sass partial that wiredep grabs from normalize-scss.","title":"How to use it"},{"location":"bower_components/normalize-scss/#browser-support","text":"Chrome (last four) Edge (version 25 and later) Firefox (last four) Firefox ESR Internet Explorer 9+ Opera (last four) Safari (last four)","title":"Browser support"},{"location":"bower_components/normalize-scss/#extended-details-and-known-issues","text":"Additional detail and explanation of the esoteric parts of normalize.css.","title":"Extended details and known issues"},{"location":"bower_components/normalize-scss/#pre-code-kbd-samp","text":"The font-family: monospace, monospace hack fixes the inheritance and scaling of font-size for preformatted text. The duplication of monospace is intentional. Source .","title":"pre, code, kbd, samp"},{"location":"bower_components/normalize-scss/#sub-sup","text":"Normally, using sub or sup affects the line-box height of text in all browsers. Source .","title":"sub, sup"},{"location":"bower_components/normalize-scss/#svgnotroot","text":"Adding overflow: hidden fixes IE9's SVG rendering. Earlier versions of IE don't support SVG, so we can safely use the :not() and :root selectors that modern browsers use in the default UA stylesheets to apply this style. Source .","title":"svg:not(:root)"},{"location":"bower_components/normalize-scss/#select","text":"By default, Chrome on OS X and Safari on OS X allow very limited styling of select , unless a border property is set. The default font weight on optgroup elements cannot safely be changed in Chrome on OSX and Safari on OS X.","title":"select"},{"location":"bower_components/normalize-scss/#typecheckbox","text":"It is recommended that you do not style checkbox and radio inputs as Firefox's implementation does not respect box-sizing, padding, or width.","title":"[type=\"checkbox\"]"},{"location":"bower_components/normalize-scss/#typenumber","text":"Certain font size values applied to number inputs cause the cursor style of the decrement button to change from default to text .","title":"[type=\"number\"]"},{"location":"bower_components/normalize-scss/#typesearch","text":"The search input is not fully stylable by default. In Chrome and Safari on OSX/iOS you can't control font , padding , border , or background . In Chrome and Safari on Windows you can't control border properly. It will apply border-width but will only show a border color (which cannot be controlled) for the outer 1px of that border. Applying -webkit-appearance: textfield addresses these issues without removing the benefits of search inputs (e.g. showing past searches). Safari (but not Chrome) will clip the cancel button on when it has padding (and textfield appearance).","title":"[type=\"search\"]"},{"location":"bower_components/normalize-scss/#contributing","text":"Please read Normalize.css' contributing guidelines . Updates to most CSS rules should be reported to the upstream Normalize.css project . Updates to the Sass should be reported in the Normalize-scss project .","title":"Contributing"},{"location":"bower_components/normalize-scss/#acknowledgements","text":"Normalize.css is a project by Nicolas Gallagher , co-created with Jonathan Neal . This Sass port is a project by John Albin Wilkins .","title":"Acknowledgements"},{"location":"bower_components/normalize-scss/#other-ports-of-normalizecss","text":"For the record, there are several other Sass ports as well. Including: https://github.com/waynegraham/compass-normalize-plugin https://github.com/ksmandersen/compass-normalize https://github.com/hail2u/normalize.scss https://github.com/kristerkari/normalize.scss https://github.com/krisbulman/normalize-libsass","title":"Other ports of Normalize.css"},{"location":"bower_components/normalize-scss/fork-versions/default/","text":"Fork-able normalize-scss for libSass or Ruby Sass Using with node-sass or libSass or Ruby Sass Copy these files to your Sass project. Start forking by altering/moving Sass variables found in _variables.scss . Edit any CSS ruleset directly rather than overriding it in later Sass.","title":"Fork-able normalize-scss<br> for libSass or Ruby Sass"},{"location":"bower_components/normalize-scss/fork-versions/default/#fork-able-normalize-scss-for-libsass-or-ruby-sass","text":"","title":"Fork-able normalize-scss for libSass or Ruby Sass"},{"location":"bower_components/normalize-scss/fork-versions/default/#using-with-node-sass-or-libsass-or-ruby-sass","text":"Copy these files to your Sass project. Start forking by altering/moving Sass variables found in _variables.scss . Edit any CSS ruleset directly rather than overriding it in later Sass.","title":"Using with node-sass or libSass or Ruby Sass"},{"location":"bower_components/normalize-scss/fork-versions/deprecated-compass/","text":"Fork-able normalize-scss for Ruby Sass and Compass 1.0 Copy these files to your Sass project. Start forking by altering/moving Sass variables found in _variables.scss . Edit any CSS ruleset directly rather than overriding it in later Sass.","title":"Fork-able normalize-scss<br> for Ruby Sass and Compass 1.0"},{"location":"bower_components/normalize-scss/fork-versions/deprecated-compass/#fork-able-normalize-scss-for-ruby-sass-and-compass-10","text":"Copy these files to your Sass project. Start forking by altering/moving Sass variables found in _variables.scss . Edit any CSS ruleset directly rather than overriding it in later Sass.","title":"Fork-able normalize-scss for Ruby Sass and Compass 1.0"},{"location":"bower_components/normalize-scss/fork-versions/typey-chroma-kss/","text":"Fork-able normalize-scss for Typey, Chroma and KSS Using with node-sass Copy these files to your Sass project. This fork-able version requires: chroma typey Add them to your package.json with: ```bash npm install --save-dev typey chroma-sass 3. Add the dependencies' directories to your nodeSass' [`includePaths` option](https://github.com/sass/node-sass#includepaths). ```js var sass = require('node-sass'), path = require('path'); sass.render({ file: scss_filename, includePaths: [ path.dirname(require.resolve('chroma-sass')), path.dirname(require.resolve('typey')) ] }, function(err, result) { /*...*/ }); Using with libSass If you are not using node-sass with libSass, you probably already know how to include 3rd party libraries into your Sass project. Copy these files to your Sass project. This fork-able version requires the chroma Sass module and the typey Sass module. Add chroma's sass directory and typey's stylesheets directory to your libSass include paths in the \"usual way\". Using with Ruby Sass In addition to copying these files to your Sass project, you'll also need to: Edit your Gemfile file to add: ```ruby gem 'chroma-sass', '~> 1.0' gem 'typey', '~> 1.0.0' 2. If you use Compass, edit your `config.rb` file to add: ```ruby require 'chroma-sass' require 'typey' Update your local Gems with: bundle install","title":"Fork-able normalize-scss<br> for Typey, Chroma and KSS"},{"location":"bower_components/normalize-scss/fork-versions/typey-chroma-kss/#fork-able-normalize-scss-for-typey-chroma-and-kss","text":"","title":"Fork-able normalize-scss for Typey, Chroma and KSS"},{"location":"bower_components/normalize-scss/fork-versions/typey-chroma-kss/#using-with-node-sass","text":"Copy these files to your Sass project. This fork-able version requires: chroma typey Add them to your package.json with: ```bash npm install --save-dev typey chroma-sass 3. Add the dependencies' directories to your nodeSass' [`includePaths` option](https://github.com/sass/node-sass#includepaths). ```js var sass = require('node-sass'), path = require('path'); sass.render({ file: scss_filename, includePaths: [ path.dirname(require.resolve('chroma-sass')), path.dirname(require.resolve('typey')) ] }, function(err, result) { /*...*/ });","title":"Using with node-sass"},{"location":"bower_components/normalize-scss/fork-versions/typey-chroma-kss/#using-with-libsass","text":"If you are not using node-sass with libSass, you probably already know how to include 3rd party libraries into your Sass project. Copy these files to your Sass project. This fork-able version requires the chroma Sass module and the typey Sass module. Add chroma's sass directory and typey's stylesheets directory to your libSass include paths in the \"usual way\".","title":"Using with libSass"},{"location":"bower_components/normalize-scss/fork-versions/typey-chroma-kss/#using-with-ruby-sass","text":"In addition to copying these files to your Sass project, you'll also need to: Edit your Gemfile file to add: ```ruby gem 'chroma-sass', '~> 1.0' gem 'typey', '~> 1.0.0' 2. If you use Compass, edit your `config.rb` file to add: ```ruby require 'chroma-sass' require 'typey' Update your local Gems with: bundle install","title":"Using with Ruby Sass"},{"location":"bower_components/normalize-scss/fork-versions/typey/","text":"Fork-able normalize-scss for Typey Using with node-sass Copy these files to your Sass project. This fork-able version requires the typey Sass module. Add it to your package.json with: ```bash npm install --save-dev typey 3. Add Typey's Sass directory to your nodeSass' [`includePaths` option](https://github.com/sass/node-sass#includepaths). ```js var sass = require('node-sass'), path = require('path'); sass.render({ file: scss_filename, includePaths: [ path.dirname(require.resolve('typey')) ] }, function(err, result) { /*...*/ }); Using with libSass If you are using libSass but not using node-sass, you probably already know how to include 3rd party libraries into your Sass project. Copy these files to your Sass project. This fork-able version requires the typey Sass module. Add typey's stylesheets directory to your libSass include paths in the \"usual way\". Using with Ruby Sass In addition to copying these files to your Sass project, you'll also need to: Edit your Gemfile file to add: ```ruby gem 'typey', '~> 1.0.0' 2. If you use Compass, edit your `config.rb` file to add: ```ruby require 'typey' Update your local Gems with: bundle install","title":"Fork-able normalize-scss<br> for Typey"},{"location":"bower_components/normalize-scss/fork-versions/typey/#fork-able-normalize-scss-for-typey","text":"","title":"Fork-able normalize-scss for Typey"},{"location":"bower_components/normalize-scss/fork-versions/typey/#using-with-node-sass","text":"Copy these files to your Sass project. This fork-able version requires the typey Sass module. Add it to your package.json with: ```bash npm install --save-dev typey 3. Add Typey's Sass directory to your nodeSass' [`includePaths` option](https://github.com/sass/node-sass#includepaths). ```js var sass = require('node-sass'), path = require('path'); sass.render({ file: scss_filename, includePaths: [ path.dirname(require.resolve('typey')) ] }, function(err, result) { /*...*/ });","title":"Using with node-sass"},{"location":"bower_components/normalize-scss/fork-versions/typey/#using-with-libsass","text":"If you are using libSass but not using node-sass, you probably already know how to include 3rd party libraries into your Sass project. Copy these files to your Sass project. This fork-able version requires the typey Sass module. Add typey's stylesheets directory to your libSass include paths in the \"usual way\".","title":"Using with libSass"},{"location":"bower_components/normalize-scss/fork-versions/typey/#using-with-ruby-sass","text":"In addition to copying these files to your Sass project, you'll also need to: Edit your Gemfile file to add: ```ruby gem 'typey', '~> 1.0.0' 2. If you use Compass, edit your `config.rb` file to add: ```ruby require 'typey' Update your local Gems with: bundle install","title":"Using with Ruby Sass"}]}