{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TripGo API The TripGo API allows you to plan door-to-door trips using a large variety of public and private transport. It integrates real-time information and, for selected providers, allows users to book and pay for transport. Getting started 1. Getting an API key Get an API key . You can try it out for free for as long as you like, as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the SkedGo website . It may take up to 5 minutes for your key to be active. Once you have an API key, send it along with every request as the X-TripGo-Key header. 2. Make a request Our API can do a lot more than just directions , but if that is what you are interested in, then try something like: curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.863,151.208)&departAfter=1532799914&modes[]=wa_wal&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g or curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.891,151.209)&modes[]=pt_pub&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g Keep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further in the F.A.Q. . 3. Where to go from here? If you're an app developer, take a look at our open source TripKit SDKs for iOS, macOS and Android . If you're a web developer, take a look at our sample app \"FastGo\" and its accompanying blog post series , or check out our Leaflet Plugin (see Demo ). If you're a backend developer, dive into the API specs , which are available in OpenAPI (formerly Swagger) format. If you know how to debug a web app, look at the network activity for our web app to get an idea of which API calls to use when. (Filter for \"satapp\".) To talk to us and other developers using our API, join our Slack team by self-invite .","title":"Getting Started"},{"location":"#tripgo-api","text":"The TripGo API allows you to plan door-to-door trips using a large variety of public and private transport. It integrates real-time information and, for selected providers, allows users to book and pay for transport.","title":"TripGo API"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#1-getting-an-api-key","text":"Get an API key . You can try it out for free for as long as you like, as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the SkedGo website . It may take up to 5 minutes for your key to be active. Once you have an API key, send it along with every request as the X-TripGo-Key header.","title":"1. Getting an API key"},{"location":"#2-make-a-request","text":"Our API can do a lot more than just directions , but if that is what you are interested in, then try something like: curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.863,151.208)&departAfter=1532799914&modes[]=wa_wal&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g or curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.891,151.209)&modes[]=pt_pub&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g Keep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further in the F.A.Q. .","title":"2. Make a request"},{"location":"#3-where-to-go-from-here","text":"If you're an app developer, take a look at our open source TripKit SDKs for iOS, macOS and Android . If you're a web developer, take a look at our sample app \"FastGo\" and its accompanying blog post series , or check out our Leaflet Plugin (see Demo ). If you're a backend developer, dive into the API specs , which are available in OpenAPI (formerly Swagger) format. If you know how to debug a web app, look at the network activity for our web app to get an idea of which API calls to use when. (Filter for \"satapp\".) To talk to us and other developers using our API, join our Slack team by self-invite .","title":"3. Where to go from here?"},{"location":"extensions/","text":"Extensions Right after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system. The TripGo API can be extended in the following ways: Unlock transport modes, regions and real-time data from services that require you to first accept their terms or acquire API credentials. Add new transport modes through our TSP Connectors (coming soon). Add new regions through our Region Connectors (coming soon). Unlocking transport modes To get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). BlaBlaCar \ud83c\udf0d Integrations : Routing, Real-time Read the terms of use of BlaBlaCar's API and make sure you comply with them in your app. Sign up to BlaBlaCar's API . Enter your BlaBlaCar auth key in your application credentials . BlaBlaCar results will start coming through the TripGo API for your API key (after at most 5 minutes). Car2go \ud83c\udf0f Integrations : Locations, Routing, Real-time, Bookings Read the terms of use of the car2go API and make sure you comply with them in your app. Mail openapi@car2go.com as described in there. Enter your Car2go consumerKey in your application credentials . Car2go results will start coming through the TripGo API for your API key (after at most 5 minutes). Flinkster \ud83c\uddea\ud83c\uddfa Integrations : Locations, Routing, Real-time Sign up to Deutsche Bahn's Flinkster API Login to Deutsche Bahn's developer website, select \"My Subscriptions\" and generate an \"Access Token\" Enter this as your Flinkster access token in your application credentials . Flinkster results will start coming through the TripGo API for your API key (after at most 5 minutes). GoGet \ud83c\udde6\ud83c\uddfa Integrations : Locations, Routing, Real-time Get in touch with GoGet 's sales team and get access to their API. Enter your GoGet ConsumerKey and GoGet ConsumerSecret in your application credentials . GoGet results will start coming through the TripGo API for your API key (after at most 5 minutes). Lyft \ud83c\uddfa\ud83c\uddf8 Integrations : Routing, Real-time, Bookings Read the terms of use of Lyft's API and make sure you comply with them in your app. Sign up to Lyft's API . Enter your Lyft Client ID and Lyft Client Secret in your application credentials . Lyft results will start coming through the TripGo API for your API key (after at most 5 minutes). MyDriver \ud83c\udf0e Integrations : Routing, Real-time Get in touch with MyDriver 's sales team and get access to their API. Enter your MyDriver username and MyDriver password in your application credentials . MyDriver results will start coming through the TripGo API for your API key (after at most 5 minutes). Ola \ud83c\uddee\ud83c\uddf3 \ud83c\udde6\ud83c\uddfa \ud83c\uddf3\ud83c\uddff \ud83c\uddec\ud83c\udde7 Integrations : Routing, Real-time Get in touch with Ola 's sales team and get access to their API. Enter your OLA ApiKey in your application credentials . Ola results will start coming through the TripGo API for your API key (after at most 5 minutes). Uber \ud83c\udf0e Integrations : Routing, Real-time, Bookings Read the terms of use of Uber's API and make sure you comply with them in your app. Sign up to Uber's ride request API . Enter your Uber client ID , Uber client secret and Uber server token in your application credentials . Uber results will start coming through the TripGo API for your API key (after at most 5 minutes). Zipcar \ud83c\uddfa\ud83c\uddf8 Integrations : Locations, Routing, Real-time Get in touch with Zipcar and get access to their API. Enter your Zipcar API key in your application credentials . Zipcar results will start coming through the TripGo API for your API key (after at most 5 minutes). Unlocking real-time data To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Live-Traffic from Google \ud83c\udf0e Read the terms of use of Google Maps and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Maps Directions API Enter your Google Maps Directions API key in your application credentials . Car results leaving now will then come augmented with Google's drive time predictions through the TripGo API for your API key (after at most 5 minutes). Live-Traffic from TomTom \ud83c\udf0e Sign up to the TomTom Maps API , making sure you read the terms and comply with them - in particular, that you're not affiliated with a prohibited party and that you're using a TomTom or TomTom licenses map UI (e.g., Apple Maps). Enter your TomTom consumer API key and TomTom consumer secret in your application credentials . Car results leaving now will then come augmented with TomTom's drive time predictions through the TripGo API for your API key (after at most 5 minutes). Chicago's CTA \ud83c\uddfa\ud83c\uddf8 Read the terms of use of CTA's API and make sure you comply with them in your app Sign up to CTA's API Enter your CTA key for Chicago in your application credentials . Real-time data for CTA for your TripGo API key will be enabled (after at most 5 minutes). Unlocking geocoding providers To get results from geocoding data for providers who aren't using Open Data when using geocoding.json endpoint, follow the instructions for the provider below. These providers will only apply for non auto-completion requests, except for What3Words ones, which can be used for both type of geocoding requests. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Foursquare \ud83c\udf0e Read the Foursquare Terms of Use and make sure you comply with them in your app. Sign up to the Foursquare Developers Site Enter your Foursquare API key in your application credentials . Add allowFoursquare=true to your geocoding requests, and then geocoding results will then come augmented with Foursquare's API through the TripGo API for your API key (after at most 5 minutes). Google Places \ud83c\udf0e Read the Places API Policies and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Places API Enter your Google Places API key in your application credentials . Add allowGoogle=true to your geocoding requests, and then geocoding results will then come augmented with Google Places's API through the TripGo API for your API key (after at most 5 minutes). What3Words \ud83c\udf0e Read the API Licence Agreement and make sure you comply with them in your app. Sign up to the What3Words API Enter your What 3 Words key in your application credentials . Add allowW3W=true to your geocoding requests, and then geocoding results will then come augmented with What3Words's API through the TripGo API for your API key (after at most 5 minutes). Yelp \ud83c\udf0e Read the Yelp Terms of Use and make sure you comply with them in your app. Sign up to the Yelp Developers Site Enter your Yelp API key in your application credentials . Add allowYelp=true to your geocoding requests, and then geocoding results will then come augmented with Yelp's API through the TripGo API for your API key (after at most 5 minutes). Unlocking regions To get results for regions with providers that aren't using Open Data, or which we haven't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Rio de Janeiro (Brazil) \ud83c\udf0e Go to Fetransport Site and make sure you agree with the data terms. Contact us if you need help for this. Forward your confirmation mail to api@skedgo.com We will then unlock the region for your API key.","title":"Extensions"},{"location":"extensions/#extensions","text":"Right after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system. The TripGo API can be extended in the following ways: Unlock transport modes, regions and real-time data from services that require you to first accept their terms or acquire API credentials. Add new transport modes through our TSP Connectors (coming soon). Add new regions through our Region Connectors (coming soon).","title":"Extensions"},{"location":"extensions/#unlocking-transport-modes","text":"To get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking transport modes"},{"location":"extensions/#blablacar","text":"Integrations : Routing, Real-time Read the terms of use of BlaBlaCar's API and make sure you comply with them in your app. Sign up to BlaBlaCar's API . Enter your BlaBlaCar auth key in your application credentials . BlaBlaCar results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"BlaBlaCar \ud83c\udf0d"},{"location":"extensions/#car2go","text":"Integrations : Locations, Routing, Real-time, Bookings Read the terms of use of the car2go API and make sure you comply with them in your app. Mail openapi@car2go.com as described in there. Enter your Car2go consumerKey in your application credentials . Car2go results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Car2go \ud83c\udf0f"},{"location":"extensions/#flinkster","text":"Integrations : Locations, Routing, Real-time Sign up to Deutsche Bahn's Flinkster API Login to Deutsche Bahn's developer website, select \"My Subscriptions\" and generate an \"Access Token\" Enter this as your Flinkster access token in your application credentials . Flinkster results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Flinkster \ud83c\uddea\ud83c\uddfa"},{"location":"extensions/#goget","text":"Integrations : Locations, Routing, Real-time Get in touch with GoGet 's sales team and get access to their API. Enter your GoGet ConsumerKey and GoGet ConsumerSecret in your application credentials . GoGet results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"GoGet \ud83c\udde6\ud83c\uddfa"},{"location":"extensions/#lyft","text":"Integrations : Routing, Real-time, Bookings Read the terms of use of Lyft's API and make sure you comply with them in your app. Sign up to Lyft's API . Enter your Lyft Client ID and Lyft Client Secret in your application credentials . Lyft results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Lyft \ud83c\uddfa\ud83c\uddf8"},{"location":"extensions/#mydriver","text":"Integrations : Routing, Real-time Get in touch with MyDriver 's sales team and get access to their API. Enter your MyDriver username and MyDriver password in your application credentials . MyDriver results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"MyDriver \ud83c\udf0e"},{"location":"extensions/#ola","text":"Integrations : Routing, Real-time Get in touch with Ola 's sales team and get access to their API. Enter your OLA ApiKey in your application credentials . Ola results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Ola \ud83c\uddee\ud83c\uddf3 \ud83c\udde6\ud83c\uddfa \ud83c\uddf3\ud83c\uddff \ud83c\uddec\ud83c\udde7"},{"location":"extensions/#uber","text":"Integrations : Routing, Real-time, Bookings Read the terms of use of Uber's API and make sure you comply with them in your app. Sign up to Uber's ride request API . Enter your Uber client ID , Uber client secret and Uber server token in your application credentials . Uber results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Uber \ud83c\udf0e"},{"location":"extensions/#zipcar","text":"Integrations : Locations, Routing, Real-time Get in touch with Zipcar and get access to their API. Enter your Zipcar API key in your application credentials . Zipcar results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Zipcar \ud83c\uddfa\ud83c\uddf8"},{"location":"extensions/#unlocking-real-time-data","text":"To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking real-time data"},{"location":"extensions/#live-traffic-from-google","text":"Read the terms of use of Google Maps and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Maps Directions API Enter your Google Maps Directions API key in your application credentials . Car results leaving now will then come augmented with Google's drive time predictions through the TripGo API for your API key (after at most 5 minutes).","title":"Live-Traffic from Google \ud83c\udf0e"},{"location":"extensions/#live-traffic-from-tomtom","text":"Sign up to the TomTom Maps API , making sure you read the terms and comply with them - in particular, that you're not affiliated with a prohibited party and that you're using a TomTom or TomTom licenses map UI (e.g., Apple Maps). Enter your TomTom consumer API key and TomTom consumer secret in your application credentials . Car results leaving now will then come augmented with TomTom's drive time predictions through the TripGo API for your API key (after at most 5 minutes).","title":"Live-Traffic from TomTom \ud83c\udf0e"},{"location":"extensions/#chicagos-cta","text":"Read the terms of use of CTA's API and make sure you comply with them in your app Sign up to CTA's API Enter your CTA key for Chicago in your application credentials . Real-time data for CTA for your TripGo API key will be enabled (after at most 5 minutes).","title":"Chicago's CTA \ud83c\uddfa\ud83c\uddf8"},{"location":"extensions/#unlocking-geocoding-providers","text":"To get results from geocoding data for providers who aren't using Open Data when using geocoding.json endpoint, follow the instructions for the provider below. These providers will only apply for non auto-completion requests, except for What3Words ones, which can be used for both type of geocoding requests. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking geocoding providers"},{"location":"extensions/#foursquare","text":"Read the Foursquare Terms of Use and make sure you comply with them in your app. Sign up to the Foursquare Developers Site Enter your Foursquare API key in your application credentials . Add allowFoursquare=true to your geocoding requests, and then geocoding results will then come augmented with Foursquare's API through the TripGo API for your API key (after at most 5 minutes).","title":"Foursquare \ud83c\udf0e"},{"location":"extensions/#google-places","text":"Read the Places API Policies and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Places API Enter your Google Places API key in your application credentials . Add allowGoogle=true to your geocoding requests, and then geocoding results will then come augmented with Google Places's API through the TripGo API for your API key (after at most 5 minutes).","title":"Google Places \ud83c\udf0e"},{"location":"extensions/#what3words","text":"Read the API Licence Agreement and make sure you comply with them in your app. Sign up to the What3Words API Enter your What 3 Words key in your application credentials . Add allowW3W=true to your geocoding requests, and then geocoding results will then come augmented with What3Words's API through the TripGo API for your API key (after at most 5 minutes).","title":"What3Words \ud83c\udf0e"},{"location":"extensions/#yelp","text":"Read the Yelp Terms of Use and make sure you comply with them in your app. Sign up to the Yelp Developers Site Enter your Yelp API key in your application credentials . Add allowYelp=true to your geocoding requests, and then geocoding results will then come augmented with Yelp's API through the TripGo API for your API key (after at most 5 minutes).","title":"Yelp \ud83c\udf0e"},{"location":"extensions/#unlocking-regions","text":"To get results for regions with providers that aren't using Open Data, or which we haven't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking regions"},{"location":"extensions/#rio-de-janeiro-brazil","text":"Go to Fetransport Site and make sure you agree with the data terms. Contact us if you need help for this. Forward your confirmation mail to api@skedgo.com We will then unlock the region for your API key.","title":"Rio de Janeiro (Brazil) \ud83c\udf0e"},{"location":"faq/","text":"General Languages Which languages does the API support? Most text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish. The translations are done in the open on Crowdin and everyone can contribute, including adding new languages. One note of causion: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them. Regions What are regions? Our API splits the world into several pieces, which we call regions. Several endpoints require you to pass along a region code, e.g., because identifiers might be duplicated around the world. You can get a list of regions by quering regions.json : curl 'https://api.tripgo.com/v1/regions.json' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -d '{\"v\":2}' Then extract the polylines from there and match your coordinates to a region. This endpoint also tells you which modes are supported by routing for a given region. I noticed URLs in those regions, how can/should I use those? Most developer should not need to worry about these and can just use the api.tripgo.com domain. However, performance critical application can use this to reduce lag and directly hit the routing servers. For advanced users : This exposes to you that our API is covered by multiple servers - though not every server covers ever region. You can use the URLs to directly query servers covering a certain region \u2013 which can be beneficial to reduce lag and is recommended for server-to-server communication. However, be aware that you should add failover from one server to another yourself then, as individual servers can go down unannounced for maintenance. You should only cache this information short term as those URLs can change without notice. Map Data Which Map Data Layer do you use? Our platform uses OSM ( Open Street Map ) for the underlying map data, and this information is used when we calculate routes (mainly for private transport modes). This data affects, for example, how we decide what routes are faster, the shapes of the resulting trips for roads, paths and cycleways, among others. We can also integrate other data layers (such as Here ) upon request. If you want to use other data layer than OSM, please get in touch with our team by mail or on Slack (by self-invite ). But I see Google Maps in TripGo apps TripGo Android app and our web app use Google Maps to display information on the map, whereas the TripGo iOS app uses Apple Maps . Note, however, that this is different from the map data used by the platform to calculate routes. Google or Apple Maps are the visual map used by front-end apps to display trips and locations to the end user. It is up to the front-ends to decide which mapping UI SDK to use. It is important to note that different mapping UIs may have restrictions in their licensing terms which other APIs and services can be used to display on and alongside those maps. Routing Mode Identifiers What are all these peculiar looking strings such as pt_pub ? Syntax The syntax of the mode string is like this: <group>_<mode that makes sense to the user>[_<provider or fine-grained mode>][_<line number>] List of groups Warning : This list can expand at any time when types of transport are added to SkedGo's backend, so if you hard-code how to interpret these identifiers, make sure to handle it gracefully if the API returns an identifier that you haven't yet seen. pt_ is for transit which runs on schedules ps_ is for taxi-like on-demand services me_ is for vehicles you drive yourself cy_ is for cycling wa_ is for walking in_ is for intercity long distance transport stationary_ is for stationary segments in between transport segments pt_ pt_pub is \"public transit\" that is accessible to public pt_pub_bus pt_pub_train pt_pub_ferry pt_pub_tram pt_pub_subway pt_pub_monorail pt_pub_cablecar pt_pub_funicular pt_pub_gondola pt_ltd_SCHOOLBUS is public transit of limited access (school buses) pt_ltd_SCHOOLBUS_<line number> for a specific school bus line ps_ ps_tax is for taxis ps_tnc is for uber and alike (TNC is California's official code for them) ps_tnc_lyft ps_tnc_sidecar ps_tnc_uber ps_shu is for (airport) shuttles me_ me_car is for your own car me_car-s is for car sharing (like ZipCar or GoGet) me_car-r is for car rental (like Budget) me_car-p is for car pooling (like BlaBlaCar) me_mot is for your own motorbike stationary_ stationary_parking-onstreet is for parking a vehicle on-street stationary_parking-offstreet is for parking a vehicle in an off-street location stationary_wait is a buffer for waiting for the following transport, e.g., waiting for a taxi or ride share to show up, but not for transferring between timetable-based public transport segments which get the special identifier below. stationary_transfer is for transferring between timetable-based public transport segments, often following a walk; note: you only get this if there are at least two public transport segments in a trip. stationary_vehicle-collect is for picking up a shared vehicle stationary_vehicle-return is for returning a shared vehicle stationary_airport-checkin is for checking in at an airport stationary_airport-checkout is for \"checking out\" off an airport, e.g., for picking up luggage and going through immigration stationary_airport-transfer is for transferring between flights at an airport Single-modal vs. multi-modal routing How do I get these sweet results which combine taxis or other private transport modes with public transport? You need to specify multiple modes in the routing.json requests, e.g., by using modes=pt_pub&modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those. What if I want to get both public-transport-only results and mixed results? By default the request with multiple modes will only return inter-modal results, no results for individual modes. The preferred way is to send off separate requests, e.g., if you want public transport, taxi, and combinations of the two, you need to send three requests: one with modes=pt_pub , one with modes=ps_tax , and one with modes=pt_pub&modes=ps_tax . Alternatively, you can send the optional allModes=true with the request that has all the modes. In that case a single request is sufficient to get all the single-modal and inter-modal results, but use this with caution as by the notes below. A few things to note: It is preferred to send separate per-mode requests as some modes depend on external API calls, which slow things down. Inter-modal results are generally not as fast to calculate due to the many combinations to crunch and them being likely to depend on multiple external API calls. By having the inter-modal request not returning single-modal results, you don't need to do any duplicate detection between the results of the different calls as they are mutually exclusive. You'll only get such inter-modal combinations where that combination is better in some way than using any individual mode by itself. It is therefore quite common that inter-modal requests result in an empty response. Trips, groups, frequencies and templates What is the logic behind trip groups and what does the frequency property mean? Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times. Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group. In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest weightedScore . Why are segments split into references and templates? This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client. Trips results Why do I get trips with the first segment of a trip already in the past? When you have a trip group, you will get trips departing before the best one matching the query. What you should do is, grey it out in the UI and don't select it by default (the weighted score is a good indicator for this). Note that you can even get a trip group only with a trip in the past, e.g., if you queried for 12:15am and the last ferry left at 12:10. Why do I get trips having segments that \"go back in time\" and result in arriving after the depart of the next one? There may be cases where a segment of a trip is delayed, and due to realtime updates, the trip gets negative waiting times, e.g., a bus is delayed by 5 minutes and the trip had a connection of 2 minutes to take a train. These cases should be handled by the app, either by alerting the user, by recomputing the trip, or by any other measure you consider appropriate. Placeholders in segment templates What are all the possible values for placeholders and how should they get interpreted? In order to use segment templates for multiple similar segments, the notes and action fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data. <NUMBER> : Placeholder for the number of short name of the transit service, e.g., segment.serviceNumber . <LINE_NAME> : Placeholder for the long name of the transit service, e.g., segment.serviceName . <DIRECTION> : Placeholder for the direction of the transit service, e.g., segment.serviceDirection . <LOCATIONS> : Placeholder for the start and end location of the segment, e.g., segment.start -> segment.end . <PLATFORM> : Placeholder for the embarkation platform of the transit service, e.g., segment.platform . <STOPS> : Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g., segment.stops . <TIME> *: Placeholder for the departure time of the segment, e.g., segment.startTime formatted as a time. Note that this can directly follow a <NUMBER> template, so you might have to add spacing. <DURATION> *: Placeholder for the total duration of the segment, e.g., segment.endTime - segment.startTime formatted as a duration string. <TRAFFIC> : (Badly named) placeholder for the total duration without traffic of the segment, e.g., segment.durationWithoutTraffic formatted as a duration string. * : Should be updated with real-time data. Advanced Routing Features How does wheelchair flag in true affect the resulting trips? There are three possible scenarios for public services, public stops, and paths: we know they are wheelchair accessible, we know they are not wheelchair accessible, or we don't have information about them. When the wheelchair flag is on, our routing engine will try to avoid services, stops and paths that are known by us to be inaccessible. In addition, we'll change 'walking' instructions to 'rolling' instructions, and indicate which sections are accessible, inaccessible or unknown. What's the action field in the alerts for? Sometimes we get real-time data that may change the accessibility status for public stops, for example when a lift is temporarily out of service in a train station. In these cases, we provide a mechanism that allows to identify the problem and send a re-route request specifically asking to avoid the stop(s) that have become inaccessible. If the embark/disembark stop of a public segment has issues, then we'll associate that segment with an alert describing the issue and containing a special action field of type rerouteExcludingStops which provides a list of the affected stop codes. Then if you want to get a new set of results avoiding those stops, you can add the avoidStops parameter to your original routing request, using the stop codes provided in the alert action field, and re-send it. Note that this new request will only avoid the stops you specifically indicated with the avoidStops parameter, so your new set of results may again include an alert for a different stop that also has issues. So you may want to send a third request asking to avoid this one too, but it's important that you include all of them in the avoidStops list, or otherwise you'll get again the stops that were first excluded. Locations Locations, cell IDs and hash codes What are the cell IDs in the locations.json endpoint? The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as $(lat*cellsPerDegree)#$(lng*cellsPerDegree) . Got it. And cellIDHashCodes ? You typically call locations.json with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use cellIDHashCodes as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed. Example Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request: { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDs\": [ \"-2540#11339\", \"-2540#11340\", \"-2540#11341\", \"-2541#11339\", \"-2541#11340\", \"-2541#11341\", \"-2542#11339\", \"-2542#11340\", \"-2542#11341\" ] } You'll then get results: { \"groups\": [ { \"hashCode\": 690784261, \"key\": \"-2540#11339\", \"stops\": [...] }, { \"hashCode\": -1940969928, \"key\": \"-2540#11340\", \"stops\": [...] } ] } You can then cache these and later on request again for changes by supplying cellIDHashCodes : { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDHashCodes\": { \"-2540#11339\": 690784261, \"-2540#11340\": -1940969928 } } Which will then only return any groups that have changed. If nothing changed, you'll just get back: { \"groups\": [] } Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself: { \"region\": \"AU_NSW_Sydney\", \"cellIDHashCodes\": { \"AU_NSW_Sydney\": 1096794422 } }","title":"F.A.Q."},{"location":"faq/#general","text":"","title":"General"},{"location":"faq/#languages","text":"Which languages does the API support? Most text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish. The translations are done in the open on Crowdin and everyone can contribute, including adding new languages. One note of causion: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them.","title":"Languages"},{"location":"faq/#regions","text":"What are regions? Our API splits the world into several pieces, which we call regions. Several endpoints require you to pass along a region code, e.g., because identifiers might be duplicated around the world. You can get a list of regions by quering regions.json : curl 'https://api.tripgo.com/v1/regions.json' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -d '{\"v\":2}' Then extract the polylines from there and match your coordinates to a region. This endpoint also tells you which modes are supported by routing for a given region. I noticed URLs in those regions, how can/should I use those? Most developer should not need to worry about these and can just use the api.tripgo.com domain. However, performance critical application can use this to reduce lag and directly hit the routing servers. For advanced users : This exposes to you that our API is covered by multiple servers - though not every server covers ever region. You can use the URLs to directly query servers covering a certain region \u2013 which can be beneficial to reduce lag and is recommended for server-to-server communication. However, be aware that you should add failover from one server to another yourself then, as individual servers can go down unannounced for maintenance. You should only cache this information short term as those URLs can change without notice.","title":"Regions"},{"location":"faq/#map-data","text":"Which Map Data Layer do you use? Our platform uses OSM ( Open Street Map ) for the underlying map data, and this information is used when we calculate routes (mainly for private transport modes). This data affects, for example, how we decide what routes are faster, the shapes of the resulting trips for roads, paths and cycleways, among others. We can also integrate other data layers (such as Here ) upon request. If you want to use other data layer than OSM, please get in touch with our team by mail or on Slack (by self-invite ). But I see Google Maps in TripGo apps TripGo Android app and our web app use Google Maps to display information on the map, whereas the TripGo iOS app uses Apple Maps . Note, however, that this is different from the map data used by the platform to calculate routes. Google or Apple Maps are the visual map used by front-end apps to display trips and locations to the end user. It is up to the front-ends to decide which mapping UI SDK to use. It is important to note that different mapping UIs may have restrictions in their licensing terms which other APIs and services can be used to display on and alongside those maps.","title":"Map Data"},{"location":"faq/#routing","text":"","title":"Routing"},{"location":"faq/#mode-identifiers","text":"What are all these peculiar looking strings such as pt_pub ?","title":"Mode Identifiers"},{"location":"faq/#syntax","text":"The syntax of the mode string is like this: <group>_<mode that makes sense to the user>[_<provider or fine-grained mode>][_<line number>]","title":"Syntax"},{"location":"faq/#list-of-groups","text":"Warning : This list can expand at any time when types of transport are added to SkedGo's backend, so if you hard-code how to interpret these identifiers, make sure to handle it gracefully if the API returns an identifier that you haven't yet seen. pt_ is for transit which runs on schedules ps_ is for taxi-like on-demand services me_ is for vehicles you drive yourself cy_ is for cycling wa_ is for walking in_ is for intercity long distance transport stationary_ is for stationary segments in between transport segments","title":"List of groups"},{"location":"faq/#pt_","text":"pt_pub is \"public transit\" that is accessible to public pt_pub_bus pt_pub_train pt_pub_ferry pt_pub_tram pt_pub_subway pt_pub_monorail pt_pub_cablecar pt_pub_funicular pt_pub_gondola pt_ltd_SCHOOLBUS is public transit of limited access (school buses) pt_ltd_SCHOOLBUS_<line number> for a specific school bus line","title":"pt_"},{"location":"faq/#ps_","text":"ps_tax is for taxis ps_tnc is for uber and alike (TNC is California's official code for them) ps_tnc_lyft ps_tnc_sidecar ps_tnc_uber ps_shu is for (airport) shuttles","title":"ps_"},{"location":"faq/#me_","text":"me_car is for your own car me_car-s is for car sharing (like ZipCar or GoGet) me_car-r is for car rental (like Budget) me_car-p is for car pooling (like BlaBlaCar) me_mot is for your own motorbike","title":"me_"},{"location":"faq/#stationary_","text":"stationary_parking-onstreet is for parking a vehicle on-street stationary_parking-offstreet is for parking a vehicle in an off-street location stationary_wait is a buffer for waiting for the following transport, e.g., waiting for a taxi or ride share to show up, but not for transferring between timetable-based public transport segments which get the special identifier below. stationary_transfer is for transferring between timetable-based public transport segments, often following a walk; note: you only get this if there are at least two public transport segments in a trip. stationary_vehicle-collect is for picking up a shared vehicle stationary_vehicle-return is for returning a shared vehicle stationary_airport-checkin is for checking in at an airport stationary_airport-checkout is for \"checking out\" off an airport, e.g., for picking up luggage and going through immigration stationary_airport-transfer is for transferring between flights at an airport","title":"stationary_"},{"location":"faq/#single-modal-vs-multi-modal-routing","text":"How do I get these sweet results which combine taxis or other private transport modes with public transport? You need to specify multiple modes in the routing.json requests, e.g., by using modes=pt_pub&modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those. What if I want to get both public-transport-only results and mixed results? By default the request with multiple modes will only return inter-modal results, no results for individual modes. The preferred way is to send off separate requests, e.g., if you want public transport, taxi, and combinations of the two, you need to send three requests: one with modes=pt_pub , one with modes=ps_tax , and one with modes=pt_pub&modes=ps_tax . Alternatively, you can send the optional allModes=true with the request that has all the modes. In that case a single request is sufficient to get all the single-modal and inter-modal results, but use this with caution as by the notes below. A few things to note: It is preferred to send separate per-mode requests as some modes depend on external API calls, which slow things down. Inter-modal results are generally not as fast to calculate due to the many combinations to crunch and them being likely to depend on multiple external API calls. By having the inter-modal request not returning single-modal results, you don't need to do any duplicate detection between the results of the different calls as they are mutually exclusive. You'll only get such inter-modal combinations where that combination is better in some way than using any individual mode by itself. It is therefore quite common that inter-modal requests result in an empty response.","title":"Single-modal vs. multi-modal routing"},{"location":"faq/#trips-groups-frequencies-and-templates","text":"What is the logic behind trip groups and what does the frequency property mean? Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times. Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group. In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest weightedScore . Why are segments split into references and templates? This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.","title":"Trips, groups, frequencies and templates"},{"location":"faq/#trips-results","text":"Why do I get trips with the first segment of a trip already in the past? When you have a trip group, you will get trips departing before the best one matching the query. What you should do is, grey it out in the UI and don't select it by default (the weighted score is a good indicator for this). Note that you can even get a trip group only with a trip in the past, e.g., if you queried for 12:15am and the last ferry left at 12:10. Why do I get trips having segments that \"go back in time\" and result in arriving after the depart of the next one? There may be cases where a segment of a trip is delayed, and due to realtime updates, the trip gets negative waiting times, e.g., a bus is delayed by 5 minutes and the trip had a connection of 2 minutes to take a train. These cases should be handled by the app, either by alerting the user, by recomputing the trip, or by any other measure you consider appropriate.","title":"Trips results"},{"location":"faq/#placeholders-in-segment-templates","text":"What are all the possible values for placeholders and how should they get interpreted? In order to use segment templates for multiple similar segments, the notes and action fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data. <NUMBER> : Placeholder for the number of short name of the transit service, e.g., segment.serviceNumber . <LINE_NAME> : Placeholder for the long name of the transit service, e.g., segment.serviceName . <DIRECTION> : Placeholder for the direction of the transit service, e.g., segment.serviceDirection . <LOCATIONS> : Placeholder for the start and end location of the segment, e.g., segment.start -> segment.end . <PLATFORM> : Placeholder for the embarkation platform of the transit service, e.g., segment.platform . <STOPS> : Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g., segment.stops . <TIME> *: Placeholder for the departure time of the segment, e.g., segment.startTime formatted as a time. Note that this can directly follow a <NUMBER> template, so you might have to add spacing. <DURATION> *: Placeholder for the total duration of the segment, e.g., segment.endTime - segment.startTime formatted as a duration string. <TRAFFIC> : (Badly named) placeholder for the total duration without traffic of the segment, e.g., segment.durationWithoutTraffic formatted as a duration string. * : Should be updated with real-time data.","title":"Placeholders in segment templates"},{"location":"faq/#advanced-routing-features","text":"How does wheelchair flag in true affect the resulting trips? There are three possible scenarios for public services, public stops, and paths: we know they are wheelchair accessible, we know they are not wheelchair accessible, or we don't have information about them. When the wheelchair flag is on, our routing engine will try to avoid services, stops and paths that are known by us to be inaccessible. In addition, we'll change 'walking' instructions to 'rolling' instructions, and indicate which sections are accessible, inaccessible or unknown. What's the action field in the alerts for? Sometimes we get real-time data that may change the accessibility status for public stops, for example when a lift is temporarily out of service in a train station. In these cases, we provide a mechanism that allows to identify the problem and send a re-route request specifically asking to avoid the stop(s) that have become inaccessible. If the embark/disembark stop of a public segment has issues, then we'll associate that segment with an alert describing the issue and containing a special action field of type rerouteExcludingStops which provides a list of the affected stop codes. Then if you want to get a new set of results avoiding those stops, you can add the avoidStops parameter to your original routing request, using the stop codes provided in the alert action field, and re-send it. Note that this new request will only avoid the stops you specifically indicated with the avoidStops parameter, so your new set of results may again include an alert for a different stop that also has issues. So you may want to send a third request asking to avoid this one too, but it's important that you include all of them in the avoidStops list, or otherwise you'll get again the stops that were first excluded.","title":"Advanced Routing Features"},{"location":"faq/#locations","text":"","title":"Locations"},{"location":"faq/#locations-cell-ids-and-hash-codes","text":"What are the cell IDs in the locations.json endpoint? The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as $(lat*cellsPerDegree)#$(lng*cellsPerDegree) . Got it. And cellIDHashCodes ? You typically call locations.json with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use cellIDHashCodes as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.","title":"Locations, cell IDs and hash codes"},{"location":"faq/#example","text":"Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request: { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDs\": [ \"-2540#11339\", \"-2540#11340\", \"-2540#11341\", \"-2541#11339\", \"-2541#11340\", \"-2541#11341\", \"-2542#11339\", \"-2542#11340\", \"-2542#11341\" ] } You'll then get results: { \"groups\": [ { \"hashCode\": 690784261, \"key\": \"-2540#11339\", \"stops\": [...] }, { \"hashCode\": -1940969928, \"key\": \"-2540#11340\", \"stops\": [...] } ] } You can then cache these and later on request again for changes by supplying cellIDHashCodes : { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDHashCodes\": { \"-2540#11339\": 690784261, \"-2540#11340\": -1940969928 } } Which will then only return any groups that have changed. If nothing changed, you'll just get back: { \"groups\": [] } Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself: { \"region\": \"AU_NSW_Sydney\", \"cellIDHashCodes\": { \"AU_NSW_Sydney\": 1096794422 } }","title":"Example"},{"location":"enterprise/bookings-api/","text":"Overview Note: Enterprise customers-only Note: Beta-only The TripGo API allows making bookings for a handful of transport service providers (TSPs). This enables your users to: Link their TSP accounts and keep credentials either stored on the client or server-side. Get a list of available TSP products for a trip. Book a specific TSP product for a single segment. Update the trip with the details of the booked TSP product. Update the trip with real-time data specific to that booking. Coming soon: Book a complete trip consisting of multiple products from multiple TSPs. In order to enable bookings for your TripGo API key, please get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials. API Endpoints Linking and unlinking accounts Before you can do any bookings, you will need to provide the relevant authentication details to the server. If the user has an account (as per the userToken header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet. auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a userToken is provided in the headers. If mode is provided, only information for that mode is returned. auth/{provider}/signin : Endpoint to link an account for the specified provider. auth/{provider}/logout : Endpoint to unlink an account for the specified provider. Auth Flow This flow will depend on the TSP and can be started in two separate ways: When linking accounts to a user. When doing a booking for that particular TSP and the user has no account already linked. This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow. For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including clientId , clientSecret , scope , authUrl , tokenUrl ; and also the required field to be POSTed, including accessToken , refreshToken and expiration . For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for Form-based Booking Flow . The end of this flow will depending on how it was started. If was started to link an account, the flow will end with an empty 204 response, when successfuly linked. If it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of Form-based Booking Flow . Getting available TSP for a trip If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment. The booking object in the segment may include: a quickBookingUrl , indicating that the quick booking flow is available. a bookingUrl , indicating that the form-based booking flow is available. Booking a segment To book a segment, either use the Form-based Booking Flow with the bookingURL either directly from the segment reference, or the Quick Booking Flow from the data returned after hitting quickBookingUrl . Form-based Booking Flow If form-based booking flow is available for a segment, the bookingUrl will return a Booking Form object with instructions to start the booking flow. A form-based booking flow will possible include the following steps: 1) return the available TSP products to allow the user choose one of them, 2) check whether we have user credentials to do the booking, if it does, skip 3, 3) start Auth flow , 4) attempt to do the booking and return the Status Form. Quick Booking Flow Getting available TSP products for a trip If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come: tripUpdateURL : A URL for fetching the trip, updated for this TSP product. bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of form-based booking flow ) title subtitle bookingTitle priceString price USDPrice surgeString surgeImageURL ETA imageURL Updating trip with booking details At the end of the booking flow, you will get a refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip. Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking. Trips with a confirmed booking will also have extra information about the confirmed booking in a field called confirmation in the booking field of the segment. This confirmation object may include detailed information about the provider , vehicle and status for the booking, with the following possible fields: a title a subtitle a valueUrl a value And also a list of possible actions depending on the status of the booking, with the following fields: a title a boolean isDestructive , indicating whether this action will cancel the booking. a internalUrl indicating the action of the url is a call to the same server and will return a bookingForm . a externalUrl indicating that the action must be handled by the app accordingly. Examples of actions with internalUrl fields are cancel booking , which will have the isDestructive field in true, and rate booking . Examples of actions with externalUrl fields are qrcode values, for showing a ticket to the user, and phone numbers, starting with tel: . Rating and Tipping Whenever available, the confirmation information will include the rate booking action, which will include an internalUrl which will return a bookingForm with the following fields: rate , an int value with min and max accepted values. feedback , a string to send an appropriate msg. tip , an int value indicating the amount to be paid as tip, in local currency. The booking form will include the action url to POST the data. Booking Form Specs Both the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps. There exists three different forms: Booking Form Auth Form Status Form All three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data. A Booking Form may include: a title a subtitle a value a BookingAction , which may include: a URL , to go to the next step in the flow a title a hudText , with a human readable string describing the action (meant to be shown while waiting the response from the backend) a boolean finalStep , meaning that the next step is the one that will actually do the booking. a boolean done , indicating that there are no more steps in the flow. a list of FormGroups . A FormGroup is a lisf of FormFields with a title and an optional footer. A FormField is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include: a (unique) id , to identify the field a title a subtitle a sidetitle a value , that will depend on the FormField type a boolean required , indicating that this is a required field to be POSTed, a boolean readOnly , indicating that this is information to be shown to the user but can not be edited. a boolean hidden , indicating that this field should NOT be shown to the user. There are several types of FormFields: string , which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER} text , for long non-editable strings switch , for boolean values option , for a list of values, will include the list and the default value address , for locations, value with the following format {lat, lng, address, name} datetime , including the time value in long and an extra field with the timezone id stepper , for int values, with extra max and min values time , for seconds since midnight password link , for urls, with an extra field called method with the following possible values: refresh meaning that this url will return the same step form, post meaning that the backend expects a POST on that url, external meaning that this will go to an external site, so, no BookingForm will be returned. bookingForm , this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request. For example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.","title":"Bookings"},{"location":"enterprise/bookings-api/#overview","text":"Note: Enterprise customers-only Note: Beta-only The TripGo API allows making bookings for a handful of transport service providers (TSPs). This enables your users to: Link their TSP accounts and keep credentials either stored on the client or server-side. Get a list of available TSP products for a trip. Book a specific TSP product for a single segment. Update the trip with the details of the booked TSP product. Update the trip with real-time data specific to that booking. Coming soon: Book a complete trip consisting of multiple products from multiple TSPs. In order to enable bookings for your TripGo API key, please get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials.","title":"Overview"},{"location":"enterprise/bookings-api/#api-endpoints","text":"","title":"API Endpoints"},{"location":"enterprise/bookings-api/#linking-and-unlinking-accounts","text":"Before you can do any bookings, you will need to provide the relevant authentication details to the server. If the user has an account (as per the userToken header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet. auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a userToken is provided in the headers. If mode is provided, only information for that mode is returned. auth/{provider}/signin : Endpoint to link an account for the specified provider. auth/{provider}/logout : Endpoint to unlink an account for the specified provider.","title":"Linking and unlinking accounts"},{"location":"enterprise/bookings-api/#auth-flow","text":"This flow will depend on the TSP and can be started in two separate ways: When linking accounts to a user. When doing a booking for that particular TSP and the user has no account already linked. This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow. For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including clientId , clientSecret , scope , authUrl , tokenUrl ; and also the required field to be POSTed, including accessToken , refreshToken and expiration . For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for Form-based Booking Flow . The end of this flow will depending on how it was started. If was started to link an account, the flow will end with an empty 204 response, when successfuly linked. If it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of Form-based Booking Flow .","title":"Auth Flow"},{"location":"enterprise/bookings-api/#getting-available-tsp-for-a-trip","text":"If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment. The booking object in the segment may include: a quickBookingUrl , indicating that the quick booking flow is available. a bookingUrl , indicating that the form-based booking flow is available.","title":"Getting available TSP for a trip"},{"location":"enterprise/bookings-api/#booking-a-segment","text":"To book a segment, either use the Form-based Booking Flow with the bookingURL either directly from the segment reference, or the Quick Booking Flow from the data returned after hitting quickBookingUrl .","title":"Booking a segment"},{"location":"enterprise/bookings-api/#form-based-booking-flow","text":"If form-based booking flow is available for a segment, the bookingUrl will return a Booking Form object with instructions to start the booking flow. A form-based booking flow will possible include the following steps: 1) return the available TSP products to allow the user choose one of them, 2) check whether we have user credentials to do the booking, if it does, skip 3, 3) start Auth flow , 4) attempt to do the booking and return the Status Form.","title":"Form-based Booking Flow"},{"location":"enterprise/bookings-api/#quick-booking-flow","text":"Getting available TSP products for a trip If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come: tripUpdateURL : A URL for fetching the trip, updated for this TSP product. bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of form-based booking flow ) title subtitle bookingTitle priceString price USDPrice surgeString surgeImageURL ETA imageURL","title":"Quick Booking Flow"},{"location":"enterprise/bookings-api/#updating-trip-with-booking-details","text":"At the end of the booking flow, you will get a refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip. Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking. Trips with a confirmed booking will also have extra information about the confirmed booking in a field called confirmation in the booking field of the segment. This confirmation object may include detailed information about the provider , vehicle and status for the booking, with the following possible fields: a title a subtitle a valueUrl a value And also a list of possible actions depending on the status of the booking, with the following fields: a title a boolean isDestructive , indicating whether this action will cancel the booking. a internalUrl indicating the action of the url is a call to the same server and will return a bookingForm . a externalUrl indicating that the action must be handled by the app accordingly. Examples of actions with internalUrl fields are cancel booking , which will have the isDestructive field in true, and rate booking . Examples of actions with externalUrl fields are qrcode values, for showing a ticket to the user, and phone numbers, starting with tel: .","title":"Updating trip with booking details"},{"location":"enterprise/bookings-api/#rating-and-tipping","text":"Whenever available, the confirmation information will include the rate booking action, which will include an internalUrl which will return a bookingForm with the following fields: rate , an int value with min and max accepted values. feedback , a string to send an appropriate msg. tip , an int value indicating the amount to be paid as tip, in local currency. The booking form will include the action url to POST the data.","title":"Rating and Tipping"},{"location":"enterprise/bookings-api/#booking-form-specs","text":"Both the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps. There exists three different forms: Booking Form Auth Form Status Form All three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data. A Booking Form may include: a title a subtitle a value a BookingAction , which may include: a URL , to go to the next step in the flow a title a hudText , with a human readable string describing the action (meant to be shown while waiting the response from the backend) a boolean finalStep , meaning that the next step is the one that will actually do the booking. a boolean done , indicating that there are no more steps in the flow. a list of FormGroups . A FormGroup is a lisf of FormFields with a title and an optional footer. A FormField is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include: a (unique) id , to identify the field a title a subtitle a sidetitle a value , that will depend on the FormField type a boolean required , indicating that this is a required field to be POSTed, a boolean readOnly , indicating that this is information to be shown to the user but can not be edited. a boolean hidden , indicating that this field should NOT be shown to the user. There are several types of FormFields: string , which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER} text , for long non-editable strings switch , for boolean values option , for a list of values, will include the list and the default value address , for locations, value with the following format {lat, lng, address, name} datetime , including the time value in long and an extra field with the timezone id stepper , for int values, with extra max and min values time , for seconds since midnight password link , for urls, with an extra field called method with the following possible values: refresh meaning that this url will return the same step form, post meaning that the backend expects a POST on that url, external meaning that this will go to an external site, so, no BookingForm will be returned. bookingForm , this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request. For example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.","title":"Booking Form Specs"},{"location":"enterprise/push/","text":"Push Notifications Note: Enterprise customers-only Note: Beta-only We support Push Notifications for both Android (using Firebase ) and iOS (using APN ) devices. In order to enable and use Push Notifications, the following steps are required: Register (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details). Each app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using data/user/push endpoint. To send PN to your user, you need to know the user ID on our database and use data/push endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted). Android You need to create your own project in Firebase and send to us the Server Key in your project settings > cloud messaging tab. For instructions on how to implement Push Notifications in Android, go to Firebase Cloud Messaging . In short, your app needs to register into FCM to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. iOS You need to configure your app for APN, follow instructions from Apple or use fastlane , and then send us both the P12 file, containing the Apple Push Notification Authentication Key , and the password to unlock it. For instructions on how to implement Push Notifications in iOS, go to Configuring Remote Notification . In short, your app needs to register into APN to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. The token returned by the iOS SDK will be a binary data object, while our backend expends a string. To turn the data into a string, use this snipped: let tokenString = tokenData.reduce(into: \"\") { $0.append(String(format: \"%02X\", $1)) } When receiving push notifications, additional fields that were provide in the data part when sending the notification, will be accessible to your app via the userInfo that's attached to the content of the notification. The clickAction will end up in the notification's content's categoryIdentifier . Sending PN If you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use data/push endpoint to send notifications to a list of users (by their userID). Notifications that we send support a title, message, sound and badge, with a ttl (time to live) value, as well as custom data which will be passed on to your apps. Be mindful of size limits imposed by Firebase or APN.","title":"Push Notifications"},{"location":"enterprise/push/#push-notifications","text":"Note: Enterprise customers-only Note: Beta-only We support Push Notifications for both Android (using Firebase ) and iOS (using APN ) devices. In order to enable and use Push Notifications, the following steps are required: Register (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details). Each app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using data/user/push endpoint. To send PN to your user, you need to know the user ID on our database and use data/push endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted).","title":"Push Notifications"},{"location":"enterprise/push/#android","text":"You need to create your own project in Firebase and send to us the Server Key in your project settings > cloud messaging tab. For instructions on how to implement Push Notifications in Android, go to Firebase Cloud Messaging . In short, your app needs to register into FCM to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database.","title":"Android"},{"location":"enterprise/push/#ios","text":"You need to configure your app for APN, follow instructions from Apple or use fastlane , and then send us both the P12 file, containing the Apple Push Notification Authentication Key , and the password to unlock it. For instructions on how to implement Push Notifications in iOS, go to Configuring Remote Notification . In short, your app needs to register into APN to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. The token returned by the iOS SDK will be a binary data object, while our backend expends a string. To turn the data into a string, use this snipped: let tokenString = tokenData.reduce(into: \"\") { $0.append(String(format: \"%02X\", $1)) } When receiving push notifications, additional fields that were provide in the data part when sending the notification, will be accessible to your app via the userInfo that's attached to the content of the notification. The clickAction will end up in the notification's content's categoryIdentifier .","title":"iOS"},{"location":"enterprise/push/#sending-pn","text":"If you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use data/push endpoint to send notifications to a list of users (by their userID). Notifications that we send support a title, message, sound and badge, with a ttl (time to live) value, as well as custom data which will be passed on to your apps. Be mindful of size limits imposed by Firebase or APN.","title":"Sending PN"},{"location":"enterprise/tripurls/","text":"Trips URLs Whenever a trip is computed, it will be returned with a list of URLs, including: temporaryURL : Temporary URL used to retried the trip, which can be used for short-term sharing. saveURL : Temporary URL used to make the trip persistent. updateURL : Optional temporary URL used to update the trip with real-time data. hookURL (beta): Optional temporary URL used to hook the trip with real-time updates. progressURL : Optional temporary URL used to report progress updates for the trip. plannedURL : Optional temporary URL used for analytics. logURL (beta): Optional temporary URL used to log the trip in the user account. shareURL : Optional persistent of this trip URL, which can be used for sharing trips (web access only) appURL : Optional persistent of this trip URL, which can be used retrieving them long term (json access only). Trip access The temporaryURL allows access to the trip for a short-term period (maximum of 7 days from the time of creation), while our platform keeps the trip in the server that computed it originally. If you want a trip to persist forever, you can use the saveURL to save it in permanent storage (requires AWS DynamoDB connection). Saving the trip will create a new unique ID, along with two new urls: shareURL for web access and appURL for app/json access. Analytics The plannedURL is meant to be used for analytics purposes, to keep track, from the returned trips, which of them the user actually took, if that is possible to determine or guess at a client/app level. The progressURL goals is to enable apps to report user progress on a specific trip, also for analytics purposes. Save trip It's available for all trips. saveURL makes sure that a trip will be accessible at a later time, beyond what would be a typical user session. Otherwise our API makes no guarantee that a trip calculated is still available later. It is important to mention that the trip saved could change when reconstructing it from our database if there's newer real-time data available. Real-time updates Its optional as not all trips would ever get real-time data updates. If our platforms has real-time information that can be used to update a computed trip, both updateURL and hookURL will be present in the response. Both support the same goal of updating the trip with real-time information, one by pulling and the other by pushing. updateURL Allows providing a hash code so that it'll only return trip details if anything about the trip has changed since you last fetched it. This is so that apps can frequently hit that endpoint and only need to parse the response if there's any changes to the trip. See documentation Pulling for changes The updateURL can be used to pull our servers for changes in the trip. This url is meant to be used by the apps to get an updated version of the trip. This endpoint will return an empty response if there is no change, otherwise, it will return the trip in the requested format. As an example, if a service is delayed, the trip will be updated to reflect that change. Also, if the trip involves a booking to a TSP, like Uber for example, it will be getting updates of the status of the ride, as soon as those are available from the external API. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the updateURL is returned. The client checks whether the trip has been updated with real-time changes by doing a GET to the updateURL . If the trip has been updated, the new updateURL should be used from now on. After two hours of not getting any update, the trip is discarded from memory. For more details, check our docs Receiving notifications The hookURL can be used to register a callback or web-hook, and our platform will then inform if any change in that trip occurs by POSTing to the registered url the tripID along with the tripURL for the client to retrieve the updated trip. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the hookURL is returned. The client that wants to receive notifications about real-time changes does a POST to the hookURL ( docs ) send the webhook as url and any required header (starting with x- ) as body of the request and obtains a 204 response. At any given time the trip is updated with any real-time change, our platform does a POST to the registered web-hook. After two hours of not getting any update, the trip is discarded from memory and won't receive any more updates. The client can also remove a web-hook, by doing a DELETE request to hookURL ( docs ), and can also get the status of the hook (to confirm whether there is a hook already registered), by doing a GET to hookURL ( docs ). Note that only one web-hook per trip can be registered, and multiple calls to hookURL to register different web-hooks will override existing ones.","title":"Trip URLs"},{"location":"enterprise/tripurls/#trips-urls","text":"Whenever a trip is computed, it will be returned with a list of URLs, including: temporaryURL : Temporary URL used to retried the trip, which can be used for short-term sharing. saveURL : Temporary URL used to make the trip persistent. updateURL : Optional temporary URL used to update the trip with real-time data. hookURL (beta): Optional temporary URL used to hook the trip with real-time updates. progressURL : Optional temporary URL used to report progress updates for the trip. plannedURL : Optional temporary URL used for analytics. logURL (beta): Optional temporary URL used to log the trip in the user account. shareURL : Optional persistent of this trip URL, which can be used for sharing trips (web access only) appURL : Optional persistent of this trip URL, which can be used retrieving them long term (json access only).","title":"Trips URLs"},{"location":"enterprise/tripurls/#trip-access","text":"The temporaryURL allows access to the trip for a short-term period (maximum of 7 days from the time of creation), while our platform keeps the trip in the server that computed it originally. If you want a trip to persist forever, you can use the saveURL to save it in permanent storage (requires AWS DynamoDB connection). Saving the trip will create a new unique ID, along with two new urls: shareURL for web access and appURL for app/json access.","title":"Trip access"},{"location":"enterprise/tripurls/#analytics","text":"The plannedURL is meant to be used for analytics purposes, to keep track, from the returned trips, which of them the user actually took, if that is possible to determine or guess at a client/app level. The progressURL goals is to enable apps to report user progress on a specific trip, also for analytics purposes.","title":"Analytics"},{"location":"enterprise/tripurls/#save-trip","text":"It's available for all trips. saveURL makes sure that a trip will be accessible at a later time, beyond what would be a typical user session. Otherwise our API makes no guarantee that a trip calculated is still available later. It is important to mention that the trip saved could change when reconstructing it from our database if there's newer real-time data available.","title":"Save trip"},{"location":"enterprise/tripurls/#real-time-updates","text":"Its optional as not all trips would ever get real-time data updates. If our platforms has real-time information that can be used to update a computed trip, both updateURL and hookURL will be present in the response. Both support the same goal of updating the trip with real-time information, one by pulling and the other by pushing. updateURL Allows providing a hash code so that it'll only return trip details if anything about the trip has changed since you last fetched it. This is so that apps can frequently hit that endpoint and only need to parse the response if there's any changes to the trip. See documentation","title":"Real-time updates"},{"location":"enterprise/tripurls/#pulling-for-changes","text":"The updateURL can be used to pull our servers for changes in the trip. This url is meant to be used by the apps to get an updated version of the trip. This endpoint will return an empty response if there is no change, otherwise, it will return the trip in the requested format. As an example, if a service is delayed, the trip will be updated to reflect that change. Also, if the trip involves a booking to a TSP, like Uber for example, it will be getting updates of the status of the ride, as soon as those are available from the external API. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the updateURL is returned. The client checks whether the trip has been updated with real-time changes by doing a GET to the updateURL . If the trip has been updated, the new updateURL should be used from now on. After two hours of not getting any update, the trip is discarded from memory. For more details, check our docs","title":"Pulling for changes"},{"location":"enterprise/tripurls/#receiving-notifications","text":"The hookURL can be used to register a callback or web-hook, and our platform will then inform if any change in that trip occurs by POSTing to the registered url the tripID along with the tripURL for the client to retrieve the updated trip. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the hookURL is returned. The client that wants to receive notifications about real-time changes does a POST to the hookURL ( docs ) send the webhook as url and any required header (starting with x- ) as body of the request and obtains a 204 response. At any given time the trip is updated with any real-time change, our platform does a POST to the registered web-hook. After two hours of not getting any update, the trip is discarded from memory and won't receive any more updates. The client can also remove a web-hook, by doing a DELETE request to hookURL ( docs ), and can also get the status of the hook (to confirm whether there is a hook already registered), by doing a GET to hookURL ( docs ). Note that only one web-hook per trip can be registered, and multiple calls to hookURL to register different web-hooks will override existing ones.","title":"Receiving notifications"},{"location":"guides/deep-links/","text":"Deep Linking For a light-weight alternative to using our API, you can also deep-link into the TripGo app. Routing results $schema://$host/go?$parameters Opens the routing results for the specified destination, and optionally the start and time: flat , flng : Start coordinates. If not specified, the user's current location is used. tlat , tlng : End coordinates. Required, unless tname is provided. tname : Destination as a search string (supports what3words ). Required, unless tlat and tlng are provided. type : 0 for leaving ASAP, 1 for leaving after time , 2 for arriving by time . Required. time : Query time in seconds since 1970. Required, unless type is set to 0 . Examples: iOS: tripgo:///go?tname=dragon.letter.spoke Web: http://tripgo.com/go?tname=dragon.letter.spoke Destination information $schema://$host/meet?$parameters Opens the search screen with the destination and arrival time filled in. lat , lng : Coordinate where to meet. Required, unless name is provided. name : Destination as a search string (supports what3words ). Required, unless lat and lng are provided. time : Arrival time in seconds since 1970. Required. Examples: iOS: tripgo:///meet?lat=-33.94501&lng=151.25807&at=1385535734 Web: http://tripgo.com/meet?lat=-33.94501&lng=151.25807&at=1385535734 Timetable $schema://$host/stop/$region/$stopCode Opens the departures timetable for a given stop. $region and $stop use region codes and stop codes as defined in our API. Examples: iOS: tripgo:///stop/AU_NSW_Sydney/2035143 Web: http://tripgo.com/stop/AU_NSW_Sydney/2035143","title":"Deep Linking"},{"location":"guides/deep-links/#deep-linking","text":"For a light-weight alternative to using our API, you can also deep-link into the TripGo app.","title":"Deep Linking"},{"location":"guides/deep-links/#routing-results","text":"$schema://$host/go?$parameters Opens the routing results for the specified destination, and optionally the start and time: flat , flng : Start coordinates. If not specified, the user's current location is used. tlat , tlng : End coordinates. Required, unless tname is provided. tname : Destination as a search string (supports what3words ). Required, unless tlat and tlng are provided. type : 0 for leaving ASAP, 1 for leaving after time , 2 for arriving by time . Required. time : Query time in seconds since 1970. Required, unless type is set to 0 . Examples: iOS: tripgo:///go?tname=dragon.letter.spoke Web: http://tripgo.com/go?tname=dragon.letter.spoke","title":"Routing results"},{"location":"guides/deep-links/#destination-information","text":"$schema://$host/meet?$parameters Opens the search screen with the destination and arrival time filled in. lat , lng : Coordinate where to meet. Required, unless name is provided. name : Destination as a search string (supports what3words ). Required, unless lat and lng are provided. time : Arrival time in seconds since 1970. Required. Examples: iOS: tripgo:///meet?lat=-33.94501&lng=151.25807&at=1385535734 Web: http://tripgo.com/meet?lat=-33.94501&lng=151.25807&at=1385535734","title":"Destination information"},{"location":"guides/deep-links/#timetable","text":"$schema://$host/stop/$region/$stopCode Opens the departures timetable for a given stop. $region and $stop use region codes and stop codes as defined in our API. Examples: iOS: tripgo:///stop/AU_NSW_Sydney/2035143 Web: http://tripgo.com/stop/AU_NSW_Sydney/2035143","title":"Timetable"},{"location":"guides/sdks/","text":"","title":"Sdks"}]}